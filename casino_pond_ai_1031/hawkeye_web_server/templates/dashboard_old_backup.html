<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CASINO Hawkeye Analysis Dashboard</title>
    <link rel="stylesheet" href="/static/css/common.css">
    <link rel="stylesheet" href="/static/css/dashboard.css">
</head>
<body>
    <!-- Run Details Modal -->
    <div id="runDetailsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Run Details</h2>
                <button class="modal-close" onclick="closeRunDetailsModal()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content will be loaded dynamically -->
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeRunDetailsModal()" style="background: #95a5a6;">Close</button>
            </div>
        </div>
    </div>

    <div class="container">

        <div class="header" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 20px;">
            <div>
                <h1 style="margin: 0;">CASINO Hawkeye Dashboard</h1>
                <p id="current-project-name" style="margin: 5px 0 0 0; font-size: 0.9em; opacity: 0.9;">
                    Loading... | <span id="total-runs-inline">-</span> runs | <span id="archive-size-inline">-</span> MB
                </p>
            </div>
            <button onclick="window.location.href='/select-project'"
                    class="btn btn-secondary" style="white-space: nowrap;">
                Change Project
            </button>
        </div>
        <div class="view-mode-badge" id="view-mode-indicator" style="
            position: fixed;
            top: 80px;
            right: 20px;
            background: #3498db;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 9998;
            display: none;
        ">
            <span id="mode-text">NORMAL VIEW</span>
        </div>

        <div class="controls">


            <div class="filter-row">
                <div class="filter-group">
                    <label for="filter-run">Run Version:</label>
                    <div class="filter-dropdown">
                        <button class="filter-button" onclick="toggleFilterDropdown('run-version')" id="filter-run-btn">
                            All Run Versions
                        </button>
                        <div class="filter-dropdown-content" id="run-version-dropdown">
                            <input type="text" class="filter-search" placeholder="Search run versions..." onkeyup="filterDropdownItems('run-version')">
                            <div id="run-version-options"></div>
                            <div class="filter-actions">
                                <button type="button" onclick="selectAllFilterOptions('run-version')" class="select-all">Select All</button>
                                <button type="button" onclick="clearAllFilterOptions('run-version')" class="clear-all">Clear All</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="filter-user">User:</label>
                    <div class="filter-dropdown">
                        <button class="filter-button" onclick="toggleFilterDropdown('user')" id="filter-user-btn">
                            All Users
                        </button>
                        <div class="filter-dropdown-content" id="user-dropdown">
                            <input type="text" class="filter-search" placeholder="Search users..." onkeyup="filterDropdownItems('user')">
                            <div id="user-options"></div>
                            <div class="filter-actions">
                                <button type="button" onclick="selectAllFilterOptions('user')" class="select-all">Select All</button>
                                <button type="button" onclick="clearAllFilterOptions('user')" class="clear-all">Clear All</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="filter-block">Block:</label>
                    <div class="filter-dropdown">
                        <button class="filter-button" onclick="toggleFilterDropdown('block')" id="filter-block-btn">
                            All Blocks
                        </button>
                        <div class="filter-dropdown-content" id="block-dropdown">
                            <input type="text" class="filter-search" placeholder="Search blocks..." onkeyup="filterDropdownItems('block')">
                            <div id="block-options"></div>
                            <div class="filter-actions">
                                <button type="button" onclick="selectAllFilterOptions('block')" class="select-all">Select All</button>
                                <button type="button" onclick="clearAllFilterOptions('block')" class="clear-all">Clear All</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="filter-dk">DK Ver/Tag:</label>
                    <div class="filter-dropdown">
                        <button class="filter-button" onclick="toggleFilterDropdown('dk')" id="filter-dk-btn">
                            All DK Versions
                        </button>
                        <div class="filter-dropdown-content" id="dk-dropdown">
                            <input type="text" class="filter-search" placeholder="Search DK versions..." onkeyup="filterDropdownItems('dk')">
                            <div id="dk-options"></div>
                            <div class="filter-actions">
                                <button type="button" onclick="selectAllFilterOptions('dk')" class="select-all">Select All</button>
                                <button type="button" onclick="clearAllFilterOptions('dk')" class="clear-all">Clear All</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <button class="btn" onclick="loadRuns()">Search Runs</button>
            <button class="btn btn-secondary" onclick="clearFilters()">Clear Filters</button>

            <!-- Table action buttons with search positioned on the right -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px; flex-wrap: wrap; gap: 10px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label style="font-weight: normal; color: #2c3e50; font-size: 10px;">Filter Run Version:</label>
                    <input type="text" id="run-version-search" placeholder="Search run versions..."
                           style="padding: 2px 6px; border: 1px solid #ccc; border-radius: 3px; font-size: 10px; width: 150px;"
                           oninput="filterByRunVersion()">
                </div>
                <div style="display: flex; gap: 8px;">
                    <button onclick="selectAllRuns()" class="btn" style="background: #2c3e50; white-space: nowrap; font-size: 10px; padding: 4px 8px;">
                    Select All
                </button>
                <button onclick="compareSelectedRuns()" class="btn" style="background: #c0392b; white-space: nowrap; font-size: 10px; padding: 4px 8px;">
                    Compare
                </button>
                <button onclick="exportSelectedRuns()" class="btn" style="background: #2980b9; white-space: nowrap; font-size: 10px; padding: 4px 8px;">
                    Export Selected
                </button>
            </div>
        </div>

        <!-- Table View -->
        <div id="table-view" class="data-table">
            <div id="loading" class="loading">Loading data...</div>
            <div id="runs-table"></div>
        </div>

        <!-- Graph View -->
        <div id="graph-view" class="graph-container" style="display: none;">
            <div id="graph-loading" class="loading">Loading graph...</div>
            <div id="graph-controls" style="margin-bottom: 15px; display: none;">
                <button class="btn" onclick="resetGraphView()">Reset View</button>
                <button class="btn" onclick="exportGraphImage()">Export Image</button>
                <button class="btn" onclick="testGraph()" style="background: #e67e22;">Debug</button>
                <span id="graph-info" style="margin-left: 15px; color: #666; font-size: 10px;"></span>
            </div>
            <div id="graph-canvas" style="width: 100%; height: 70vh; border: 1px solid #ddd; background: #f8f9fa;"></div>
        </div>

        <!-- Comparison Section -->
        <div id="comparison-section" style="display: none; margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
            <h3 style="color: #2c3e50; margin-bottom: 20px;">Keyword Comparison</h3>
            <div id="comparison-content"></div>
        </div>

        <div class="footer">
            <p>CASINO Hawkeye Analysis Dashboard - Powered by Flask & SQLite</p>
            <p>Last updated: <span id="last-update">-</span></p>
        </div>
    </div>

    <script>
        // Load statistics on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Load current project name and statistics together
            Promise.all([
                fetch('/api/current-project').then(r => r.json()),
                fetch('/api/statistics').then(r => r.json())
            ]).then(([projectData, stats]) => {
                if (projectData.project) {
                    document.getElementById('current-project-name').innerHTML =
                        'Project: ' + projectData.project +
                        ' | <span id="total-runs-inline">' + stats.total_entries + '</span> runs' +
                        ' | <span id="archive-size-inline">' + stats.archive_size_mb + '</span> MB';
                }
                document.getElementById('last-update').textContent = new Date().toLocaleString();
            }).catch(error => {
                console.error('Error loading project info:', error);
            });

            loadRuns();
            initializeAutoFilters();
        });

        let allRunVersions = [];
        let allKeywords = [];
        let allRuns = [];
        let activeFilters = {
            'run-version': [],
            'user': [],
            'block': [],
            'dk': []
        };

        // Graph view variables
        let currentView = 'table';
        let graphData = null;
        let selectedNode = null;
        let graphSimulation = null;


        async function loadStatistics() {
            try {
                const response = await fetch('/api/statistics');
                const stats = await response.json();

                document.getElementById('total-runs-inline').textContent = stats.total_entries;
                document.getElementById('archive-size-inline').textContent = stats.archive_size_mb;
                document.getElementById('last-update').textContent = new Date().toLocaleString();
            } catch (error) {
                console.error('Error loading statistics:', error);
            }
        }

        async function loadRuns() {
            const loading = document.getElementById('loading');
            const table = document.getElementById('runs-table');

            loading.style.display = 'block';
            table.innerHTML = '';

            try {
                // Get all runs and keywords for filtering
                const [runsResponse, keywordsResponse] = await Promise.all([
                    fetch('/api/runs'),
                    fetch('/api/keywords')
                ]);

                allRuns = await runsResponse.json();
                originalAllRuns = [...allRuns]; // Store original copy
                allKeywords = await keywordsResponse.json();

                // Group keywords by run version
                const keywordsByRun = {};
                allKeywords.forEach(keyword => {
                    if (!keywordsByRun[keyword.run_version]) {
                        keywordsByRun[keyword.run_version] = {};
                    }
                    if (!keywordsByRun[keyword.run_version][keyword.task_name]) {
                        keywordsByRun[keyword.run_version][keyword.task_name] = [];
                    }
                    keywordsByRun[keyword.run_version][keyword.task_name].push(keyword);
                });

                // Create run versions with keyword data
                allRunVersions = allRuns.map(run => ({
                    ...run,
                    keywords: keywordsByRun[run.run_version] || {}
                }));

                // Apply auto-filters
                const filteredRuns = applyAutoFilters(allRunVersions);

                loading.style.display = 'none';

                if (filteredRuns.length === 0) {
                    table.innerHTML = '<div class="loading">No runs found matching the criteria.</div>';
                    return;
                }

                // Store filtered runs for sorting functionality
                window.filteredRuns = filteredRuns;

                // Use updateTableWithRuns to render the table consistently
                updateTableWithRuns(filteredRuns);

            } catch (error) {
                loading.style.display = 'none';
                table.innerHTML = '<div class="error">Error loading runs: ' + error.message + '</div>';
            }
        }

        async function exportCSV() {
            try {
                const response = await fetch('/api/export/csv');
                const blob = await response.blob();

                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'hawkeye_archive_export.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                // Show success message
                const table = document.getElementById('runs-table');
                table.insertAdjacentHTML('beforebegin', '<div class="success">CSV export downloaded successfully!</div>');
                setTimeout(() => {
                    const successDiv = document.querySelector('.success');
                    if (successDiv) successDiv.remove();
                }, 3000);

            } catch (error) {
                const table = document.getElementById('runs-table');
                table.insertAdjacentHTML('beforebegin', '<div class="error">Export failed: ' + error.message + '</div>');
            }
        }



        function showRunDetailsModal(index) {
            const run = allRunVersions[index];
            const modal = document.getElementById('runDetailsModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');

            // Set modal title
            modalTitle.textContent = `Run Details: ${run.run_version}`;

            // Build modal content
            let html = `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div><strong>Run Version:</strong> ${run.run_version}</div>
                        <div><strong>User:</strong> ${run.user_name}</div>
                        <div><strong>Block:</strong> ${run.block_name}</div>
                        <div><strong>DK Ver/Tag:</strong> ${run.dk_ver_tag}</div>
                        <div><strong>Base Dir:</strong> ${run.base_dir}</div>
                        <div><strong>Top Name:</strong> ${run.top_name}</div>
                    </div>
                </div>
            `;

            if (Object.keys(run.keywords).length === 0) {
                html += '<p style="color: #7f8c8d; font-style: italic; text-align: center; padding: 40px;">No keywords found for this run.</p>';
            } else {
                html += '<h3 style="margin-bottom: 15px; color: #2c3e50;">Tasks & Keywords</h3>';

                Object.entries(run.keywords).forEach(([taskName, keywords]) => {
                    const taskKeywordCount = keywords.length;

                    html += `
                        <div style="margin-bottom: 25px; border: 1px solid #ddd; border-radius: 6px; overflow: hidden;">
                            <div style="background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%); color: white; padding: 12px 15px; font-weight: bold; display: flex; justify-content: space-between; align-items: center;">
                                <span>${taskName}</span>
                                <span style="background: rgba(255,255,255,0.2); padding: 4px 12px; border-radius: 12px; font-size: 12px;">${taskKeywordCount} keywords</span>
                            </div>
                            <div style="padding: 15px;">
                                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px;">
                    `;

                    keywords.forEach(keyword => {
                        const value = keyword.keyword_value;
                        const unit = keyword.keyword_unit;
                        const displayValue = unit ? `${value} ${unit}` : value;

                        html += `
                            <div style="background: white; border: 1px solid #e0e6ed; border-radius: 4px; padding: 10px; transition: box-shadow 0.2s;" onmouseover="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.1)'" onmouseout="this.style.boxShadow='none'">
                                <div style="font-weight: 600; color: #2c3e50; margin-bottom: 6px; font-size: 13px;">${keyword.keyword_name}</div>
                                <div style="color: #e74c3c; font-weight: bold; font-size: 15px;">${displayValue}</div>
                            </div>
                        `;
                    });

                    html += `
                                </div>
                            </div>
                        </div>
                    `;
                });
            }

            modalBody.innerHTML = html;
            modal.style.display = 'block';

            // Close modal when clicking outside of it
            window.onclick = function(event) {
                if (event.target == modal) {
                    closeRunDetailsModal();
                }
            };
        }

        function closeRunDetailsModal() {
            document.getElementById('runDetailsModal').style.display = 'none';
        }

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeRunDetailsModal();
            }
        });

        // Global sorting state
        let currentSortColumn = null;
        let currentSortDirection = 'asc';

        // Add at line 1015, REPLACE entire sortTable function:
        function sortTable(column) {
            // Prevent sorting in transposed view - different structure
            if (isTransposed) {
                alert('Sorting is only available in Normal View. Please switch views to sort data.');
                return;
            }

            // Update visual indicators
            document.querySelectorAll('.sort-indicator').forEach(indicator => {
                indicator.classList.remove('sort-asc', 'sort-desc');
                indicator.innerHTML = '#';
            });

            const currentIndicator = document.getElementById(`${column}-sort`);
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortDirection = 'asc';
            }

            // Update indicator with text symbols
            if (currentIndicator) {
                currentIndicator.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                currentIndicator.innerHTML = currentSortDirection === 'asc' ? '^' : 'v';
            }

            // Only sort if we have valid filtered runs
            if (window.filteredRuns && window.filteredRuns.length > 0) {
                window.filteredRuns.sort((a, b) => {
                    let aVal, bVal;

                    switch (column) {
                        case 'run_version':
                            aVal = (a.run_version || '').toString();
                            bVal = (b.run_version || '').toString();
                            break;
                        case 'user_name':
                            aVal = (a.user_name || '').toString();
                            bVal = (b.user_name || '').toString();
                            break;
                        case 'block_name':
                            aVal = (a.block_name || '').toString();
                            bVal = (b.block_name || '').toString();
                            break;
                        case 'dk_ver_tag':
                            aVal = (a.dk_ver_tag || '').toString();
                            bVal = (b.dk_ver_tag || '').toString();
                            break;
                        case 'task_count':
                            aVal = Object.keys(a.keywords || {}).length;
                            bVal = Object.keys(b.keywords || {}).length;
                            break;
                        case 'keyword_count':
                            aVal = Object.values(a.keywords || {}).flat().length;
                            bVal = Object.values(b.keywords || {}).flat().length;
                            break;
                        case 'archive_timestamp':
                            aVal = new Date(a.archive_timestamp || 0).getTime();
                            bVal = new Date(b.archive_timestamp || 0).getTime();
                            break;
                        default:
                            return 0;
                    }

                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return currentSortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                    } else {
                        const aStr = String(aVal);
                        const bStr = String(bVal);
                        return currentSortDirection === 'asc' ?
                            aStr.localeCompare(bStr, undefined, { numeric: true, sensitivity: 'base' }) :
                            bStr.localeCompare(aStr, undefined, { numeric: true, sensitivity: 'base' });
                    }
                });

                updateTableWithRuns(window.filteredRuns);
            }
        }


        function filterByRunVersion() {
            const searchTerm = document.getElementById('run-version-search').value.toLowerCase().trim();

            if (!searchTerm) {
                loadRuns(); // Reload with current filters
                return;
            }

            // Start with original unfiltered data, then apply auto-filters
            let baseFiltered = applyAutoFilters([...originalAllRuns]);

            // Filter runs that match the run version search term
            const filteredRuns = baseFiltered.filter(run => {
                return run.run_version.toLowerCase().includes(searchTerm);
            });

            // Group ALL keywords by run version (not just matching ones)
            const keywordsByRun = {};
            allKeywords.forEach(keyword => {
                if (!keywordsByRun[keyword.run_version]) {
                    keywordsByRun[keyword.run_version] = {};
                }
                if (!keywordsByRun[keyword.run_version][keyword.task_name]) {
                    keywordsByRun[keyword.run_version][keyword.task_name] = [];
                }
                keywordsByRun[keyword.run_version][keyword.task_name].push(keyword);
            });

            // Add complete keyword data to filtered runs
            const filtered = filteredRuns.map(run => ({
                ...run,
                keywords: keywordsByRun[run.run_version] || {}
            }));

            // Update the table with filtered results
            updateTableWithRuns(filtered);
        }

        function updateTableWithRuns(runs) {
            const table = document.getElementById('runs-table');

            if (runs.length === 0) {
                table.innerHTML = '<div class="loading">No runs found matching the criteria.</div>';
                return;
            }

            // Store filtered runs for sorting functionality
            window.filteredRuns = runs;

            // Build table
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th style="width: 4%;">
                                <input type="checkbox" id="select-all-runs-checkbox" onchange="toggleAllRuns()">
                            </th>
                            <th style="width: 6%;">Details</th>
                                <th onclick="sortTable('run_version')" style="cursor: pointer; user-select: none;" title="Click to sort by Run Version">
                                    Run Version <span id="run_version-sort" class="sort-indicator">#</span>
                                </th>
                                <th onclick="sortTable('user_name')" style="cursor: pointer; user-select: none;" title="Click to sort by User">
                                    User <span id="user_name-sort" class="sort-indicator">#</span>
                                </th>
                                <th onclick="sortTable('block_name')" style="cursor: pointer; user-select: none;" title="Click to sort by Block">
                                    Block <span id="block_name-sort" class="sort-indicator">#</span>
                                </th>
                                <th onclick="sortTable('dk_ver_tag')" style="cursor: pointer; user-select: none;" title="Click to sort by DK Ver/Tag">
                                    DK Ver/Tag <span id="dk_ver_tag-sort" class="sort-indicator">#</span>
                                </th>
                                <th onclick="sortTable('task_count')" style="cursor: pointer; user-select: none;" title="Click to sort by Tasks">
                                    Tasks <span id="task_count-sort" class="sort-indicator">#</span>
                                </th>
                                <th onclick="sortTable('keyword_count')" style="cursor: pointer; user-select: none;" title="Click to sort by Keywords">
                                    Keywords <span id="keyword_count-sort" class="sort-indicator">#</span>
                                </th>
                                <th onclick="sortTable('archive_timestamp')" style="cursor: pointer; user-select: none;" title="Click to sort by Archived Date">
                                    Archived <span id="archive_timestamp-sort" class="sort-indicator">#</span>
                                </th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            runs.forEach((run, index) => {
                const archiveDate = new Date(run.archive_timestamp).toLocaleString('en-US', {
                    month: '2-digit',
                    day: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                const taskCount = Object.keys(run.keywords).length;
                const keywordCount = Object.values(run.keywords).flat().length;

                    html += `
                        <tr data-index="${index}" data-run-id="${run.run_version}">
                            <td style="text-align: center;">
                                <input type="checkbox" class="run-checkbox" data-run-id="${run.run_version}" data-run-version="${run.run_version}">
                            </td>
                        <td style="text-align: center;">
                            <button onclick="showRunDetailsModal(${index})"
                                    style="padding: 2px 4px; background: #2980b9; color: white; border: 1px solid #2980b9; cursor: pointer; font-size: 10px; border-radius: 3px;">
                                Details
                            </button>
                        </td>
                        <td><strong>${run.run_version}</strong></td>
                        <td>${run.user_name}</td>
                        <td>${run.block_name}</td>
                        <td>${run.dk_ver_tag}</td>
                        <td style="text-align: center;"><span style="background: #27ae60; color: white; padding: 2px 6px; border-radius: 3px;">${taskCount}</span></td>
                        <td style="text-align: center;"><span style="background: #c0392b; color: white; padding: 2px 6px; border-radius: 3px;">${keywordCount}</span></td>
                        <td>${archiveDate}</td>
                                                    <td>
                                <button class="btn" onclick="viewRunDetails('${run.run_version}')" style="padding: 2px 6px; font-size: 10px;">
                                    Open
                                </button>
                            </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            table.innerHTML = html;
        }

        function toggleAllRuns() {
            const selectAllCheckbox = document.getElementById('select-all-runs-checkbox');
            const checkboxes = document.querySelectorAll('.run-checkbox');

            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
        }

        function selectAllRuns() {
            const checkboxes = document.querySelectorAll('.run-checkbox');

            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });

            document.getElementById('select-all-runs-checkbox').checked = true;
        }




        function clearFilters() {
            // Clear all auto-filters
            Object.keys(activeFilters).forEach(filterType => {
                activeFilters[filterType] = [];
            });

            // Clear search inputs
            const runVersionSearch = document.getElementById('run-version-search');
            if (runVersionSearch) {
                runVersionSearch.value = '';
            }

            // Update filter buttons
            updateFilterButtons();

            // Clear all checkboxes
            const checkboxes = document.querySelectorAll('.run-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            document.getElementById('select-all-runs-checkbox').checked = false;

            // Hide comparison section if visible
            document.getElementById('comparison-section').style.display = 'none';

            // Reload runs with cleared filters
            loadRuns();
        }

        function compareSelectedRuns() {
            const checkboxes = document.querySelectorAll('.run-checkbox:checked');

            if (checkboxes.length < 1) {
                alert('Please select at least 1 run version to compare.');
                return;
            }

            console.log('Compare button clicked, found checkboxes:', checkboxes.length);
            console.log('allRunVersions length:', allRunVersions.length);
            console.log('Active filters:', activeFilters);

            const selectedRuns = [];
            checkboxes.forEach(checkbox => {
                const runVersion = checkbox.dataset.runId; // This now contains run_version
                console.log('Looking for run with version:', runVersion);
                console.log('Available runs:', allRunVersions.map(r => r.run_version));

                const run = allRunVersions.find(r => r.run_version === runVersion);
                console.log('Selected run with version', runVersion, ':', run);
                console.log('Checkbox data attributes:', {
                    runId: checkbox.dataset.runId,
                    runVersion: checkbox.dataset.runVersion,
                    index: checkbox.dataset.index
                });

                // Ensure we have the complete run data with keywords
                if (run && run.keywords) {
                    // Verify the keywords structure
                    const taskCount = Object.keys(run.keywords).length;
                    const keywordCount = Object.values(run.keywords).flat().length;
                    console.log(`Run ${run.run_version}: ${taskCount} tasks, ${keywordCount} keywords`);

                    selectedRuns.push(run);
                } else if (!run) {
                    console.error('Run not found for version:', runVersion);
                    alert(`Warning: Run version "${runVersion}" not found in available runs.`);
                } else {
                    console.error('Run missing keywords data:', run);
                    alert(`Warning: Run ${run.run_version} has no keyword data.`);
                }
            });

            if (selectedRuns.length === 0) {
                alert('No valid runs with keyword data found for comparison.');
                return;
            }

            console.log('Selected runs for comparison:', selectedRuns);
            showComparison(selectedRuns);
        }


        function showComparison(runs) {
            console.log('=== showComparison called ===');
            console.log('Runs received:', runs.length);

            if (!runs || runs.length === 0) {
                alert('No runs selected for comparison.');
                return;
            }

            currentComparisonRuns = runs;
            isTransposed = false;

            const allKeywordNames = new Set();
            const keywordsByRun = {};  // Changed from {} to object literal

            runs.forEach(function(run) {  // Changed arrow function to regular function
                console.log('Processing run:', run.run_version);
                console.log('Run keywords structure:', run.keywords);

                keywordsByRun[run.run_version] = [];

                if (run.keywords) {
                    if (Array.isArray(run.keywords)) {
                        run.keywords.forEach(function(keyword) {
                            if (keyword && keyword.keyword_name) {
                                allKeywordNames.add(keyword.keyword_name);
                                keywordsByRun[run.run_version].push(keyword);
                            }
                        });
                    } else if (typeof run.keywords === 'object') {
                        Object.entries(run.keywords).forEach(function(entry) {
                            var taskName = entry[0];
                            var keywords = entry[1];

                            if (Array.isArray(keywords)) {
                                keywords.forEach(function(keyword) {
                                    if (keyword && keyword.keyword_name) {
                                        allKeywordNames.add(keyword.keyword_name);
                                        var keywordCopy = {};
                                        for (var key in keyword) {
                                            keywordCopy[key] = keyword[key];
                                        }
                                        keywordCopy.task_name = keyword.task_name || taskName;
                                        keywordsByRun[run.run_version].push(keywordCopy);
                                    }
                                });
                            }
                        });
                    }
                }
            });

            console.log('Total unique keywords found:', allKeywordNames.size);

            if (allKeywordNames.size === 0) {
                alert('No keywords found in the selected runs.');
                return;
            }

            var formattedRuns = runs.map(function(run) {
                var formattedRun = {
                    run_version: run.run_version,
                    user_name: run.user_name,
                    block_name: run.block_name,
                    dk_ver_tag: run.dk_ver_tag,
                    completion_rate: run.completion_rate,
                    archive_timestamp: run.archive_timestamp,
                    keywords: {}
                };

                var runKeywords = keywordsByRun[run.run_version] || [];
                runKeywords.forEach(function(keyword) {
                    var taskName = keyword.task_name || 'unknown';
                    if (!formattedRun.keywords[taskName]) {
                        formattedRun.keywords[taskName] = [];
                    }
                    formattedRun.keywords[taskName].push(keyword);
                });

                return formattedRun;
            });

            var comparisonData = {
                runs: formattedRuns,
                keywords: Array.from(allKeywordNames).sort(),
                originalKeywords: Array.from(allKeywordNames).sort(),
                isTransposed: false,
                timestamp: new Date().toISOString(),
                comparisonId: 'comparison_' + Date.now(),
                runCount: formattedRuns.length,
                keywordCount: allKeywordNames.size
            };

            console.log('Final comparison data:', comparisonData);

            try {
                var dataString = JSON.stringify(comparisonData);
                console.log('Data string length:', dataString.length);
                sessionStorage.setItem('hawkeyeComparisonData', dataString);
                console.log('Successfully stored in sessionStorage');

                var stored = sessionStorage.getItem('hawkeyeComparisonData');
                console.log('Verification - stored data exists:', !!stored);
            } catch (error) {
                console.error('Error storing in sessionStorage:', error);
                alert('Error preparing comparison data: ' + error.message);
                return;
            }

            cleanupComparisonInterface();

            var timestamp = new Date().getTime();
            var windowName = 'hawkeye_comparison_' + timestamp;

            console.log('Opening new window...');
            var newWindow = window.open(
                '/comparison-view',
                windowName,
                'width=1400,height=900,scrollbars=yes,resizable=yes,toolbar=no,menubar=no'
            );

            if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
                console.warn('Popup blocked, trying _blank');
                window.open('/comparison-view', '_blank');
            } else {
                console.log('New window opened successfully');
            }
        }


        function hideComparison() {
            document.getElementById('comparison-section').style.display = 'none';
        }

        // Keyword grouping function
        // Helper function to check if keyword matches a template-based pattern
        function matchesTemplate(keyword, templateName) {
            // Check if template contains variables like {mode}, {corner}, etc.
            if (!templateName.includes('{')) {
                return false;
            }

            // Convert template to regex pattern
            // Replace template variables with regex patterns
            let pattern = templateName
                .replace(/\{mode\}/g, '[^_]+')              // mode: any non-underscore chars
                .replace(/\{corner\}/g, '[^_]+(?:_[^_]+)*') // corner: can have underscores (e.g., ss_0p81v_m40c_Cworst_T)
                .replace(/\{path_type\}/g, '[^_]+')         // path_type: reg2reg, all, etc.
                .replace(/\{noise_type\}/g, '[^_]+')        // noise_type: above_low, below_high
                .replace(/\{task_name\}/g, '[^_]+')         // task_name: place, route, etc.
                // Escape special regex characters in the rest of the string
                .replace(/\./g, '\\.');

            // Create regex with anchors
            const regex = new RegExp('^' + pattern + '$');

            return regex.test(keyword);
        }

        // Helper function to get group order from YAML configuration
        function getGroupOrderFromYAML() {
            const groupSet = new Set();
            const preferredOrder = ['err/warn', 'timing', 'congestion', 'utilization'];

            // Extract all unique groups from YAML configuration
            // Check both 'tasks' and 'task_templates' sections
            if (keywordGroupConfig) {
                // Check tasks section
                if (keywordGroupConfig.tasks) {
                    for (const taskName in keywordGroupConfig.tasks) {
                        const task = keywordGroupConfig.tasks[taskName];
                        if (task.keywords) {
                            for (const keywordConfig of task.keywords) {
                                if (keywordConfig.group) {
                                    groupSet.add(keywordConfig.group);
                                }
                            }
                        }
                    }
                }

                // Check task_templates section
                if (keywordGroupConfig.task_templates) {
                    for (const templateName in keywordGroupConfig.task_templates) {
                        const template = keywordGroupConfig.task_templates[templateName];
                        if (template.keywords) {
                            for (const keywordConfig of template.keywords) {
                                if (keywordConfig.group) {
                                    groupSet.add(keywordConfig.group);
                                }
                            }
                        }
                    }
                }
            }

            // Build ordered list: preferred groups first, then remaining alphabetically
            const groupOrder = [];

            // Add preferred groups if they exist in YAML
            preferredOrder.forEach(group => {
                if (groupSet.has(group)) {
                    groupOrder.push(group);
                    groupSet.delete(group);
                }
            });

            // Add remaining groups alphabetically
            const remainingGroups = Array.from(groupSet).sort();
            groupOrder.push(...remainingGroups);

            return groupOrder;
        }

        function groupKeywordsByConvention(keywords) {
            const groups = {};

            keywords.forEach(keyword => {
                let groupName = 'Other Keywords';

                // Get group from YAML configuration
                // Check both 'tasks' and 'task_templates' sections
                if (keywordGroupConfig) {
                    // Search through tasks section
                    if (keywordGroupConfig.tasks) {
                        for (const taskName in keywordGroupConfig.tasks) {
                            const task = keywordGroupConfig.tasks[taskName];
                            if (task.keywords) {
                                for (const keywordConfig of task.keywords) {
                                    // Try exact match first
                                    if (keywordConfig.name === keyword && keywordConfig.group) {
                                        groupName = keywordConfig.group;
                                        break;
                                    }
                                    // Try prefix match for derived keywords (e.g., s_tns_all from s_tns)
                                    if (keywordConfig.group && !keywordConfig.name.includes('{') &&
                                        keyword.startsWith(keywordConfig.name + '_')) {
                                        groupName = keywordConfig.group;
                                        break;
                                    }
                                    // Try template match for template-based keywords
                                    if (keywordConfig.group && matchesTemplate(keyword, keywordConfig.name)) {
                                        groupName = keywordConfig.group;
                                        break;
                                    }
                                }
                            }
                            if (groupName !== 'Other Keywords') break;
                        }
                    }

                    // If not found in tasks, search through task_templates section
                    if (groupName === 'Other Keywords' && keywordGroupConfig.task_templates) {
                        for (const templateName in keywordGroupConfig.task_templates) {
                            const template = keywordGroupConfig.task_templates[templateName];
                            if (template.keywords) {
                                for (const keywordConfig of template.keywords) {
                                    // Try exact match first
                                    if (keywordConfig.name === keyword && keywordConfig.group) {
                                        groupName = keywordConfig.group;
                                        break;
                                    }
                                    // Try prefix match for derived keywords (e.g., s_tns_all from s_tns)
                                    if (keywordConfig.group && !keywordConfig.name.includes('{') &&
                                        keyword.startsWith(keywordConfig.name + '_')) {
                                        groupName = keywordConfig.group;
                                        break;
                                    }
                                    // Try template match for template-based keywords
                                    if (keywordConfig.group && matchesTemplate(keyword, keywordConfig.name)) {
                                        groupName = keywordConfig.group;
                                        break;
                                    }
                                }
                            }
                            if (groupName !== 'Other Keywords') break;
                        }
                    }
                }

                if (!groups[groupName]) {
                    groups[groupName] = [];
                }
                groups[groupName].push(keyword);
            });

            // Sort keywords within each group
            Object.keys(groups).forEach(group => {
                groups[group].sort();
            });

            // Sort groups - dynamically extract order from vista_casino.yaml
            const sortedGroups = {};
            const groupOrder = getGroupOrderFromYAML();

            groupOrder.forEach(groupName => {
                if (groups[groupName]) {
                    sortedGroups[groupName] = groups[groupName];
                }
            });

            // Add any groups not in YAML-defined order (shouldn't happen but be safe)
            Object.keys(groups).sort().forEach(groupName => {
                if (!groupOrder.includes(groupName) && groupName !== 'Other Keywords') {
                    sortedGroups[groupName] = groups[groupName];
                }
            });

            if (groups['Other Keywords']) {
                sortedGroups['Other Keywords'] = groups['Other Keywords'];
            }

            return sortedGroups;
        }


        // Keyword selection functions
        function selectAllKeywords() {
            const checkboxes = document.querySelectorAll('.keyword-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateKeywordCount();
        }

        function clearAllKeywords() {
            const checkboxes = document.querySelectorAll('.keyword-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            updateKeywordCount();
        }

        function updateKeywordCount() {
            const checkboxes = document.querySelectorAll('.keyword-checkbox:checked');
            const totalKeywords = document.querySelectorAll('.keyword-checkbox').length;
            document.getElementById('selected-keyword-count').textContent = checkboxes.length;

            // Store current selection state
            if (checkboxes.length > 0) {
                window.lastSelectedKeywords = Array.from(checkboxes).map(cb => cb.value);
            }
        }

        function applyKeywordSelection() {
            const selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
                .map(checkbox => checkbox.value);

            if (selectedKeywords.length === 0) {
                alert('Please select at least one keyword to compare.');
                return;
            }

            // Store selection state for future use
            window.lastSelectedKeywords = selectedKeywords;

            // Open comparison in new window/tab
            openComparisonInNewWindow(currentComparisonRuns, selectedKeywords, false);
        }

        function populateComparisonTable(selectedKeywords) {
            const tableBody = document.getElementById('comparison-table-body');
            let html = '';

            selectedKeywords.forEach(keywordName => {
                html += `
                    <tr style="border-bottom: 1px solid #ddd;">
                        <td style="padding: 2px 4px; border: 1px solid #ddd; font-weight: normal; background: #f8f9fa; position: sticky; left: 0;">${keywordName}</td>
                `;

                currentComparisonRuns.forEach(run => {
                    // Find this keyword in this run
                    let keywordValue = '-';
                    let cellStyle = 'padding: 2px 4px; border: 1px solid #ddd; text-align: center; color: #7f8c8d;';

                    Object.values(run.keywords).flat().forEach(keyword => {
                        if (keyword.keyword_name === keywordName) {
                            const unit = keyword.keyword_unit;
                            keywordValue = unit ? `${keyword.keyword_value} ${unit}` : keyword.keyword_value;
                            cellStyle = 'padding: 2px 4px; border: 1px solid #ddd; text-align: center; font-weight: normal; color: #2c3e50;';
                        }
                    });

                    html += `<td style="${cellStyle}">${keywordValue}</td>`;
                });

                html += `</tr>`;
            });

            tableBody.innerHTML = html;

            // Make columns draggable after populating
            makeColumnsDraggable();
        }

        let isTransposed = false;
        let currentComparisonRuns = [];

        function transposeTable() {
            if (currentComparisonRuns.length === 0) {
                alert('No comparison data available to transpose.');
                return;
            }

            // Get current keyword selection
            let selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
                .map(checkbox => checkbox.value);

            // If no keywords selected, try to restore from stored state
            if (selectedKeywords.length === 0 && window.lastSelectedKeywords) {
                selectedKeywords = window.lastSelectedKeywords;
                // Restore checkbox states
                document.querySelectorAll('.keyword-checkbox').forEach(checkbox => {
                    checkbox.checked = selectedKeywords.includes(checkbox.value);
                });
            }

            // If still no keywords, select all
            if (selectedKeywords.length === 0) {
                selectAllKeywords();
                selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
                    .map(checkbox => checkbox.value);
            }

            // Store current selection
            window.lastSelectedKeywords = selectedKeywords;

            // Open comparison in new window/tab
            openComparisonInNewWindow(currentComparisonRuns, selectedKeywords, true);
        }

        function openComparisonInNewWindow(runs, selectedKeywords, isTransposed = false) {
            // Always select all available keywords for comparison
            const allKeywords = getAllAvailableKeywords(runs);

            // Create comparison data with all keywords
            const comparisonData = {
                runs: runs,
                keywords: allKeywords,
                originalKeywords: selectedKeywords, // Keep original selection for reference
                isTransposed: isTransposed,
                timestamp: new Date().toISOString()
            };

            // Store data in sessionStorage for the new window
            sessionStorage.setItem('hawkeyeComparisonData', JSON.stringify(comparisonData));

            // Clean up any existing comparison interface in main window
            cleanupComparisonInterface();

            // Open new window with comparison
            const newWindow = window.open(
                '/comparison-view',
                'hawkeye_comparison',
                'width=1200,height=800,scrollbars=yes,resizable=yes,toolbar=no,menubar=no'
            );

            // Fallback: if popup blocked, open in new tab
            if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
                window.open('/comparison-view', '_blank');
            }
        }

        function getAllAvailableKeywords(runs) {
            const allKeywords = new Set();

            runs.forEach(run => {
                if (run.keywords) {
                    Object.values(run.keywords).flat().forEach(k => {
                        if (k.keyword_name) {
                            allKeywords.add(k.keyword_name);
                        }
                    });
                }
            });

            return Array.from(allKeywords).sort();
        }

        function cleanupComparisonInterface() {
            // Hide comparison section in main window
            const comparisonSection = document.getElementById('comparison-section');
            if (comparisonSection) {
                comparisonSection.style.display = 'none';
            }

            // Reset any comparison state
            if (window.lastSelectedKeywords) {
                delete window.lastSelectedKeywords;
            }
        }

        function showTransposedComparison(runs, selectedKeywords = null) {
            const comparisonContent = document.getElementById('comparison-content');

            // Check if comparison interface exists, if not recreate it
            if (!comparisonContent || comparisonContent.children.length === 0) {
                // Recreate the comparison interface first
                showComparison(currentComparisonRuns);
                // Then switch to transposed view
                setTimeout(() => {
                    showTransposedComparison(runs, selectedKeywords);
                }, 100);
                return;
            }

            // Use provided selectedKeywords or get from checkboxes
            if (!selectedKeywords) {
                selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
                    .map(checkbox => checkbox.value);

                // If no keywords selected, try to get from previous state or select all
                if (selectedKeywords.length === 0) {
                    // Check if we have stored selection state
                    if (window.lastSelectedKeywords && window.lastSelectedKeywords.length > 0) {
                        selectedKeywords = window.lastSelectedKeywords;
                        // Restore checkbox states
                        document.querySelectorAll('.keyword-checkbox').forEach(checkbox => {
                            checkbox.checked = selectedKeywords.includes(checkbox.value);
                        });
                    } else {
                        // Fallback: select all keywords
                        selectAllKeywords();
                        selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
                            .map(checkbox => checkbox.value);
                    }
                }
            }

            // Store current selection for future use
            window.lastSelectedKeywords = selectedKeywords;

            let html = `
                <div id="comparison-table-container" style="display: block;">
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                            <thead>
                                <tr style="background: #34495e; color: white;">
                                    <th style="padding: 2px 4px; border: 1px solid #ddd; position: sticky; left: 0; background: #34495e;">Run Version</th>
            `;

            // Keywords as column headers (transposed view)
            selectedKeywords.forEach(keywordName => {
                html += `<th style="padding: 2px 4px; border: 1px solid #ddd; min-width: 120px; writing-mode: vertical-rl; text-orientation: mixed;" class="rotated-header">${keywordName}</th>`;
            });

            html += `
                            </tr>
                        </thead>
                        <tbody>
            `;

            // Create rows for each run
            runs.forEach(run => {
                html += `
                    <tr style="border-bottom: 1px solid #ddd;">
                        <td style="padding: 2px 4px; border: 1px solid #ddd; font-weight: normal; background: #f8f9fa; position: sticky; left: 0;">${run.run_version}</td>
                `;

                selectedKeywords.forEach(keywordName => {
                    // Find this keyword in this run
                    let keywordValue = '-';
                    let cellStyle = 'padding: 2px 4px; border: 1px solid #ddd; text-align: center; color: #7f8c8d;';

                    Object.values(run.keywords).flat().forEach(keyword => {
                        if (keyword.keyword_name === keywordName) {
                            const unit = keyword.keyword_unit;
                            keywordValue = unit ? `${keyword.keyword_value} ${unit}` : keyword.keyword_value;
                            cellStyle = 'padding: 2px 4px; border: 1px solid #ddd; text-align: center; font-weight: normal; color: #2c3e50;';
                        }
                    });

                    html += `<td style="${cellStyle}">${keywordValue}</td>`;
                });

                html += `</tr>`;
            });

            html += `
                        </tbody>
                    </table>
                </div>
                <div id="comparison-controls" style="margin-top: 15px; display: block;">
                                           <button onclick="transposeTable()"
                               style="padding: 8px 16px; background: #d35400; color: white; border: 1px solid #d35400; cursor: pointer; margin-right: 10px;">
                           Open Comparison in New Window
                       </button>
                    <button onclick="resetColumnOrder()"
                            style="padding: 8px 16px; background: #e67e22; color: white; border: 1px solid #e67e22; cursor: pointer; margin-right: 10px;">
                        Reset Column Order
                    </button>
                    <button onclick="hideComparison()"
                            style="padding: 8px 16px; background: #7f8c8d; color: white; border: 1px solid #7f8c8d; cursor: pointer;">
                        Close Comparison
                    </button>
                </div>
            `;

            comparisonContent.innerHTML = html;

            // Make columns draggable in transposed view
            makeColumnsDraggable();
        }

        function exportSelectedRuns() {
            const checkboxes = document.querySelectorAll('.run-checkbox:checked');

            if (checkboxes.length === 0) {
                alert('Please select at least one run version to export.');
                return;
            }

            console.log('Exporting selected runs:', checkboxes.length, 'checkboxes found');
            console.log('Active filters:', activeFilters);

            // Get selected runs and all available keywords
            const selectedRuns = [];
            const allKeywords = new Set();

            checkboxes.forEach(checkbox => {
                const runVersion = checkbox.dataset.runId; // This now contains run_version
                console.log('Looking for run with version:', runVersion);

                const run = allRunVersions.find(r => r.run_version === runVersion);
                if (run) {
                    console.log('Processing run:', run.run_version, 'with keywords:', Object.keys(run.keywords || {}));
                    console.log('Checkbox data attributes:', {
                        runId: checkbox.dataset.runId,
                        runVersion: checkbox.dataset.runVersion,
                        index: checkbox.dataset.index
                    });
                    selectedRuns.push(run);
                } else {
                    console.error('Run not found for version:', runVersion);
                    alert(`Warning: Run version "${runVersion}" not found in available runs.`);
                }

                // Collect all keywords from selected runs
                if (run.keywords) {
                    Object.values(run.keywords).flat().forEach(keyword => {
                        if (keyword && keyword.keyword_name) {
                            allKeywords.add(keyword.keyword_name);
                        }
                    });
                }
            });

            console.log('Total keywords found:', allKeywords.size);
            console.log('Selected runs:', selectedRuns.map(r => r.run_version));

            if (allKeywords.size === 0) {
                alert('No keywords found in selected runs. Please check if the runs have keyword data.');
                return;
            }

            // Export exactly as displayed in the main dashboard table: Keywords as rows, Runs as columns
            const sortedKeywords = Array.from(allKeywords).sort();
            console.log('Sorted keywords for export:', sortedKeywords);

            // Create TSV content matching the table display exactly
            let csvContent = 'Keyword';

            // Add run versions as headers
            selectedRuns.forEach(run => {
                csvContent += `\t${run.run_version}`;
            });
            csvContent += '\n';

            console.log('Header row created:', csvContent);

            // Add data rows (one per keyword)
            sortedKeywords.forEach(keywordName => {
                csvContent += `"${keywordName}"`;

                selectedRuns.forEach(run => {
                    let value = '--';
                    if (run.keywords) {
                        Object.values(run.keywords).flat().forEach(keyword => {
                            if (keyword && keyword.keyword_name === keywordName) {
                                value = keyword.keyword_unit ? `${keyword.keyword_value} ${keyword.keyword_unit}` : keyword.keyword_value;
                            }
                        });
                    }
                    csvContent += `\t"${value}"`;
                });

                csvContent += '\n';
            });

            console.log('Export content created, length:', csvContent.length);
            console.log('First 200 characters:', csvContent.substring(0, 200));

            // Download TSV (Tab-Separated Values)
            const blob = new Blob([csvContent], { type: 'text/tab-separated-values' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `hawkeye_main_dashboard_${new Date().toISOString().split('T')[0]}.tsv`;
            a.click();
            window.URL.revokeObjectURL(url);

            const runNames = selectedRuns.map(r => r.run_version);
            alert(`Exported ${sortedKeywords.length} keywords from ${runNames.length} runs.\\n\\nThe TSV matches exactly what you see in the main dashboard table.\\n\\nRuns: ${runNames.join(', ')}`);
        }

        async function viewRunDetails(runVersion) {
            try {
                // Find the run in allRunVersions by run_version
                const run = allRunVersions.find(r => r.run_version === runVersion);
                if (!run) {
                    alert('Run not found: ' + runVersion);
                    return;
                }

                // For now, just show the run data we already have
                const runData = run;

                // Create a new window with run details
                const newWindow = window.open('', '_blank', 'width=800,height=600');
                newWindow.document.write(`
                    <html>
                        <head>
                            <title>Run Details - ${runData.run_version || 'Unknown'}</title>
                            <style>
                                body { font-family: 'Segoe UI', sans-serif; padding: 20px; }
                                .header { background: #3498db; color: white; padding: 20px; margin: -20px -20px 20px -20px; }
                                .task { background: #f8f9fa; padding: 15px; margin: 10px 0; border-radius: 5px; }
                                .keyword { margin: 5px 0; padding: 5px; background: white; border-radius: 3px; }
                                pre { background: #2c3e50; color: white; padding: 15px; border-radius: 5px; overflow: auto; }
                            </style>
                        </head>
                        <body>
                            <div class="header">
                                <h1>? Run Details</h1>
                                <p>Run Version: ${runData.run_version || 'Unknown'}</p>
                            </div>
                            <pre>${JSON.stringify(runData, null, 2)}</pre>
                        </body>
                    </html>
                `);

            } catch (error) {
                alert('Error loading run details: ' + error.message);
            }
        }

        // Auto-filter functionality
        async function initializeAutoFilters() {
            try {
                const response = await fetch('/api/runs');
                const runs = await response.json();

                // Extract unique values for each filter
                const runVersions = [...new Set(runs.map(r => r.run_version).filter(Boolean))].sort();
                const users = [...new Set(runs.map(r => r.user_name).filter(Boolean))].sort();
                const blocks = [...new Set(runs.map(r => r.block_name).filter(Boolean))].sort();
                const dkVersions = [...new Set(runs.map(r => r.dk_ver_tag).filter(Boolean))].sort();

                // Populate filter options
                populateFilterOptions('run-version', runVersions);
                populateFilterOptions('user', users);
                populateFilterOptions('block', blocks);
                populateFilterOptions('dk', dkVersions);

            } catch (error) {
                console.error('Error initializing auto-filters:', error);
            }
        }

        function populateFilterOptions(filterType, options) {
            const optionsContainer = document.getElementById(`${filterType}-options`);
            if (!optionsContainer) return;

            optionsContainer.innerHTML = '';

            options.forEach(option => {
                const link = document.createElement('a');
                link.href = '#';
                link.textContent = option;
                link.onclick = (e) => {
                    e.preventDefault();
                    toggleFilterOption(filterType, option);
                };
                optionsContainer.appendChild(link);
            });

            // Apply dynamic height based on number of items
            applyDynamicDropdownHeight(filterType, options.length);
        }

        function applyDynamicDropdownHeight(filterType, itemCount) {
            const dropdown = document.getElementById(`${filterType}-dropdown`);
            if (!dropdown) return;

            // Remove any existing height classes
            dropdown.classList.remove('show-all');

            // If 10 or fewer items, show all without scrolling
            if (itemCount <= 10) {
                dropdown.classList.add('show-all');
            }
        }

        function toggleFilterDropdown(filterType) {
            const dropdown = document.getElementById(`${filterType}-dropdown`);
            const button = document.getElementById(`filter-${filterType.split('-')[0]}-btn`);
            const dropdownContainer = dropdown.closest('.filter-dropdown');

            // Close all other dropdowns
            document.querySelectorAll('.filter-dropdown-content').forEach(d => {
                if (d !== dropdown) {
                    d.classList.remove('show');
                }
            });

            // Remove active class from all dropdown containers
            document.querySelectorAll('.filter-dropdown').forEach(container => {
                container.classList.remove('active');
            });

            // Toggle current dropdown
            dropdown.classList.toggle('show');

            // Add active class to current dropdown container if open
            if (dropdown.classList.contains('show')) {
                dropdownContainer.classList.add('active');
            }

            // Update button state
            document.querySelectorAll('.filter-button').forEach(b => {
                if (b !== button) {
                    b.classList.remove('active');
                }
            });
            button.classList.toggle('active');
            // Ensure dynamic height is applied when dropdown opens
            if (dropdown.classList.contains('show')) {
                const optionsContainer = document.getElementById(`${filterType}-options`);
                if (optionsContainer) {
                    const itemCount = optionsContainer.querySelectorAll('a').length;
                    applyDynamicDropdownHeight(filterType, itemCount);
                }
            }
        }

        function filterDropdownItems(filterType) {
            const searchTerm = document.querySelector(`#${filterType}-dropdown .filter-search`).value.toLowerCase();
            let options;

            if (filterType === 'task') {
                options = document.querySelectorAll(`#${filterType}-options a`);
            } else {
                options = document.querySelectorAll(`#${filterType}-options a`);
            }

            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                if (text.includes(searchTerm)) {
                    option.style.display = 'block';
                } else {
                    option.style.display = 'none';
                }
            });
        }



        function toggleFilterOption(filterType, option) {
            const index = activeFilters[filterType].indexOf(option);

            if (index > -1) {
                activeFilters[filterType].splice(index, 1);
            } else {
                activeFilters[filterType].push(option);
            }

            updateFilterOptions(filterType);
            updateFilterButtons();
            loadRuns();
        }

        function updateFilterOptions(filterType) {
            const optionsContainer = document.getElementById(`${filterType}-options`);
            if (!optionsContainer) return;

            const links = optionsContainer.querySelectorAll('a');
            links.forEach(link => {
                if (activeFilters[filterType].includes(link.textContent)) {
                    link.classList.add('selected');
                } else {
                    link.classList.remove('selected');
                }
            });
        }

        function updateFilterButtons() {
            const filterTypes = ['run-version', 'user', 'block', 'dk'];
            const buttonLabels = {
                'run-version': 'Run Version',
                'user': 'User',
                'block': 'Block',
                'dk': 'DK Ver/Tag'
            };

            filterTypes.forEach(filterType => {
                const button = document.getElementById(`filter-${filterType.split('-')[0]}-btn`);
                if (!button) return;

                const filters = activeFilters[filterType];
                if (filters.length === 0) {
                    button.textContent = `All ${buttonLabels[filterType]}s`;
                    button.classList.remove('has-filters');
                } else if (filters.length === 1) {
                    button.textContent = filters[0];
                    button.classList.add('has-filters');
                } else {
                    button.textContent = `${filters.length} ${buttonLabels[filterType]}s selected`;
                    button.classList.add('has-filters');
                }
            });
        }

        function filterDropdownItems(filterType) {
            const searchInput = document.querySelector(`#${filterType}-dropdown .filter-search`);
            const searchTerm = searchInput.value.toLowerCase();
            const optionsContainer = document.getElementById(`${filterType}-options`);

            if (!optionsContainer) return;

            const links = optionsContainer.querySelectorAll('a');
            let visibleCount = 0;
            links.forEach(link => {
                const text = link.textContent.toLowerCase();
                if (text.includes(searchTerm)) {
                    link.style.display = 'block';
                    visibleCount++;
                } else {
                    link.style.display = 'none';
                }
            });

            // Update dropdown height based on visible items
            applyDynamicDropdownHeight(filterType, visibleCount);
        }

        function selectAllFilterOptions(filterType) {
            const optionsContainer = document.getElementById(`${filterType}-options`);
            if (!optionsContainer) return;

            const links = optionsContainer.querySelectorAll('a');
            links.forEach(link => {
                if (link.style.display !== 'none') {
                    const option = link.textContent;
                    if (!activeFilters[filterType].includes(option)) {
                        activeFilters[filterType].push(option);
                    }
                }
            });

            updateFilterOptions(filterType);
            updateFilterButtons();
            loadRuns();
        }

        function clearAllFilterOptions(filterType) {
            activeFilters[filterType] = [];
            updateFilterOptions(filterType);
            updateFilterButtons();
            loadRuns();
        }

        function applyAutoFilters(runs) {
            return runs.filter(run => {
                // Check run version filter
                if (activeFilters['run-version'].length > 0 &&
                    !activeFilters['run-version'].includes(run.run_version)) {
                    return false;
                }

                // Check user filter
                if (activeFilters['user'].length > 0 &&
                    !activeFilters['user'].includes(run.user_name)) {
                    return false;
                }

                // Check block filter
                if (activeFilters['block'].length > 0 &&
                    !activeFilters['block'].includes(run.block_name)) {
                    return false;
                }

                // Check DK version filter
                if (activeFilters['dk'].length > 0 &&
                    !activeFilters['dk'].includes(run.dk_ver_tag)) {
                    return false;
                }

                return true;
            });
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.filter-dropdown')) {
                document.querySelectorAll('.filter-dropdown-content').forEach(dropdown => {
                    dropdown.classList.remove('show');
                });
                document.querySelectorAll('.filter-button').forEach(button => {
                    button.classList.remove('active');
                });
                document.querySelectorAll('.filter-dropdown').forEach(container => {
                    container.classList.remove('active');
                });
            }
        });


        async function loadGraphData() {
            const loading = document.getElementById('graph-loading');
            const controls = document.getElementById('graph-controls');

            loading.style.display = 'block';
            controls.style.display = 'none';

            try {
                // Check if D3.js is loaded and functional
                if (typeof d3 === 'undefined' || typeof d3.forceSimulation === 'undefined') {
                    console.warn('D3.js not available, will use fallback visualization');
                }

                // Get all runs and keywords
                const [runsResponse, keywordsResponse] = await Promise.all([
                    fetch('/api/runs'),
                    fetch('/api/keywords')
                ]);

                const runs = await runsResponse.json();
                const keywords = await keywordsResponse.json();

                console.log('Loaded runs:', runs.length);
                console.log('Loaded keywords:', keywords.length);

                // Process data for graph
                graphData = processGraphData(runs, keywords);

                console.log('Processed graph data:', graphData);

                loading.style.display = 'none';
                controls.style.display = 'block';

                renderGraph();

            } catch (error) {
                loading.style.display = 'none';
                console.error('Error loading graph data:', error);

                                 // Show error message in the graph canvas
                 const canvas = document.getElementById('graph-canvas');
                 canvas.innerHTML = `
                     <div style="padding: 20px; text-align: center; color: #e74c3c;">
                         <h3>Error Loading Graph</h3>
                         <p>${error.message}</p>
                         <p>Falling back to enhanced visualization mode...</p>
                         <button onclick="loadGraphData()" class="btn" style="margin-top: 10px;">Retry</button>
                     </div>
                 `;

                 // Try to render with fallback anyway
                 setTimeout(() => {
                     if (graphData) {
                         renderEnhancedFallbackGraph();
                     }
                 }, 1000);
            }
        }

        function processGraphData(runs, keywords) {
            // Group keywords by run version
            const keywordsByRun = {};
            keywords.forEach(keyword => {
                if (!keywordsByRun[keyword.run_version]) {
                    keywordsByRun[keyword.run_version] = new Set();
                }
                keywordsByRun[keyword.run_version].add(keyword.keyword_name);
            });

            // Create nodes (runs)
            const nodes = runs.map(run => ({
                id: run.run_version,
                label: run.run_version,
                user: run.user_name,
                completion: run.completion_rate,
                keywords: keywordsByRun[run.run_version] || new Set(),
                size: Math.max(10, Math.min(30, run.completion_rate / 3)),
                color: getNodeColor(run.completion_rate)
            }));

            // Create edges (shared keywords)
            const edges = [];
            const processedPairs = new Set();

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const node1 = nodes[i];
                    const node2 = nodes[j];

                    // Find shared keywords
                    const sharedKeywords = new Set([...node1.keywords].filter(x => node2.keywords.has(x)));

                    if (sharedKeywords.size > 0) {
                        const pairKey = `${node1.id}-${node2.id}`;
                        if (!processedPairs.has(pairKey)) {
                            edges.push({
                                source: node1.id,
                                target: node2.id,
                                weight: sharedKeywords.size,
                                sharedKeywords: Array.from(sharedKeywords)
                            });
                            processedPairs.add(pairKey);
                        }
                    }
                }
            }

            return { nodes, edges };
        }

        function getNodeColor(completionRate) {
            if (completionRate >= 90) return '#27ae60'; // Green
            if (completionRate >= 70) return '#f39c12'; // Orange
            if (completionRate >= 50) return '#e67e22'; // Dark Orange
            return '#e74c3c'; // Red
        }

        function renderGraph() {
            if (!graphData) {
                console.error('No graph data available');
                return;
            }

            console.log('Rendering graph with data:', graphData);

            const canvas = document.getElementById('graph-canvas');
            canvas.innerHTML = '';

            // Check if D3.js is available and properly loaded
            if (typeof d3 === 'undefined' || typeof d3.forceSimulation === 'undefined' || typeof d3.select === 'undefined') {
                console.warn('D3.js not available, using enhanced fallback visualization');
                renderEnhancedFallbackGraph();
                return;
            }

            try {
                // Create SVG
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                svg.style.background = '#f8f9fa';
                canvas.appendChild(svg);

                // Add legend
                const legend = createLegend();
                canvas.appendChild(legend);

                // Create tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'graph-tooltip';
                tooltip.style.display = 'none';
                canvas.appendChild(tooltip);

                // Get canvas dimensions
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                // Create force simulation
                graphSimulation = d3.forceSimulation(graphData.nodes)
                    .force('link', d3.forceLink(graphData.edges).id(d => d.id).distance(100))
                    .force('charge', d3.forceManyBody().strength(-300))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(d => d.size + 5));

                // Create edges
                const edges = svg.append('g')
                    .selectAll('line')
                    .data(graphData.edges)
                    .enter().append('line')
                    .attr('class', 'graph-edge')
                    .style('stroke-width', d => Math.max(1, Math.min(5, d.weight)));

                // Create nodes
                const nodes = svg.append('g')
                    .selectAll('circle')
                    .data(graphData.nodes)
                    .enter().append('circle')
                    .attr('class', 'graph-node')
                    .attr('r', d => d.size)
                    .style('fill', d => d.color)
                    .style('stroke', '#2c3e50')
                    .style('stroke-width', 2)
                    .on('mouseover', function(event, d) {
                        showTooltip(event, d);
                        d3.select(this).style('stroke-width', 3);
                    })
                    .on('mouseout', function() {
                        hideTooltip();
                        d3.select(this).style('stroke-width', 2);
                    })
                    .on('click', function(event, d) {
                        selectNode(d);
                    });

                // Add node labels
                const labels = svg.append('g')
                    .selectAll('text')
                    .data(graphData.nodes)
                    .enter().append('text')
                    .text(d => d.label.length > 15 ? d.label.substring(0, 12) + '...' : d.label)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '.35em')
                    .style('font-size', '10px')
                    .style('font-weight', 'bold')
                    .style('fill', '#2c3e50')
                    .style('pointer-events', 'none');

                // Update positions on simulation tick
                graphSimulation.on('tick', () => {
                    edges
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    nodes
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);

                    labels
                        .attr('x', d => d.x)
                        .attr('y', d => d.y);
                });

                // Update info
                updateGraphInfo();

            } catch (error) {
                console.error('Error rendering D3.js graph:', error);
                renderEnhancedFallbackGraph();
            }
        }

        function createLegend() {
            const legend = document.createElement('div');
            legend.className = 'graph-legend';
            legend.innerHTML = `
                <div style="font-weight: normal; margin-bottom: 8px;">Completion Rate</div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #27ae60;"></div>
                    <span>90-100%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span>70-89%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e67e22;"></div>
                    <span>50-69%</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>&lt;50%</span>
                </div>
                <div style="margin-top: 8px; font-size: 10px; color: #666;">
                    Node size = completion rate<br>
                    Edge thickness = shared keywords
                </div>
            `;
            return legend;
        }

        function showTooltip(event, node) {
            const tooltip = document.querySelector('.graph-tooltip');
            const sharedKeywords = selectedNode ?
                [...node.keywords].filter(k => selectedNode.keywords.has(k)) :
                [];

            tooltip.innerHTML = `
                <div style="font-weight: normal; margin-bottom: 5px;">${node.label}</div>
                <div>User: ${node.user}</div>
                <div>Completion: ${node.completion}%</div>
                <div>Keywords: ${node.keywords.size}</div>
                ${selectedNode ? `<div style="margin-top: 5px; color: #3498db;">Shared: ${sharedKeywords.length} keywords</div>` : ''}
            `;

            tooltip.style.display = 'block';
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY - 10 + 'px';
        }

        function hideTooltip() {
            const tooltip = document.querySelector('.graph-tooltip');
            tooltip.style.display = 'none';
        }

        function selectNode(node) {
            if (selectedNode === node) {
                // Deselect
                selectedNode = null;
                document.querySelectorAll('.graph-node').forEach(n => n.classList.remove('selected'));
                document.querySelectorAll('.graph-edge').forEach(e => e.classList.remove('highlighted'));
            } else {
                // Select new node
                selectedNode = node;
                document.querySelectorAll('.graph-node').forEach(n => n.classList.remove('selected'));
                document.querySelectorAll('.graph-edge').forEach(e => e.classList.remove('highlighted'));

                // Highlight selected node
                document.querySelectorAll('.graph-node').forEach(n => {
                    if (n.__data__ && n.__data__.id === node.id) {
                        n.classList.add('selected');
                    }
                });

                // Highlight connected edges
                document.querySelectorAll('.graph-edge').forEach(e => {
                    if (e.__data__ && (e.__data__.source.id === node.id || e.__data__.target.id === node.id)) {
                        e.classList.add('highlighted');
                    }
                });
            }
        }

        function resetGraphView() {
            selectedNode = null;
            document.querySelectorAll('.graph-node').forEach(n => n.classList.remove('selected'));
            document.querySelectorAll('.graph-edge').forEach(e => e.classList.remove('highlighted'));
            hideTooltip();
        }

        function updateGraphInfo() {
            const info = document.getElementById('graph-info');
            if (graphData) {
                info.textContent = `${graphData.nodes.length} runs, ${graphData.edges.length} connections`;
            }
        }

                function renderEnhancedFallbackGraph() {
            const canvas = document.getElementById('graph-canvas');

            let html = `
                <div style="padding: 20px;">
                    <h3 style="color: #2c3e50; margin-bottom: 15px;">Hawkeye Graph View (Enhanced Mode)</h3>
                    <p style="color: #7f8c8d; margin-bottom: 20px;">
                        <strong>Note:</strong> Using enhanced visualization mode. All data relationships are preserved and fully functional.
                    </p>

                    <div style="margin-bottom: 20px; padding: 15px; background: #e8f4fd; border-radius: 8px; border-left: 4px solid #3498db;">
                        <h4 style="margin: 0 0 10px 0; color: #2c3e50;">Graph Information</h4>
                        <p style="margin: 5px 0; font-size: 10px;"><strong>Total Runs:</strong> ${graphData.nodes.length}</p>
                        <p style="margin: 5px 0; font-size: 10px;"><strong>Total Connections:</strong> ${graphData.edges.length}</p>
                        <p style="margin: 5px 0; font-size: 10px;"><strong>Average Connections per Run:</strong> ${(graphData.edges.length * 2 / graphData.nodes.length).toFixed(1)}</p>
                    </div>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
            `;

             graphData.nodes.forEach(node => {
                 const connections = graphData.edges.filter(edge =>
                     edge.source === node.id || edge.target === node.id
                 ).length;

                 // Get connected run names and shared keywords
                 const connectedRuns = graphData.edges
                     .filter(edge => edge.source === node.id || edge.target === node.id)
                     .map(edge => {
                         const targetId = edge.source === node.id ? edge.target : edge.source;
                         const sharedKeywords = edge.sharedKeywords || [];
                         return {
                             id: targetId,
                             keywords: sharedKeywords
                         };
                     })
                     .slice(0, 3); // Show first 3 connections

                 html += `
                     <div style="border: 2px solid ${node.color}; border-radius: 8px; padding: 15px; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: all 0.3s ease;"
                          onmouseover="this.style.transform='scale(1.02)'"
                          onmouseout="this.style.transform='scale(1)'">
                         <h4 style="margin: 0 0 8px 0; color: #2c3e50; font-size: 10px;">${node.label}</h4>
                         <p style="margin: 5px 0; font-size: 10px;"><strong>User:</strong> ${node.user}</p>
                         <p style="margin: 5px 0; font-size: 10px;"><strong>Completion:</strong> <span style="color: ${node.color}; font-weight: normal;">${node.completion}%</span></p>
                         <p style="margin: 5px 0; font-size: 10px;"><strong>Keywords:</strong> ${node.keywords.size}</p>
                         <p style="margin: 5px 0; font-size: 10px;"><strong>Connections:</strong> ${connections}</p>
                         ${connectedRuns.length > 0 ? `
                             <div style="margin-top: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                                 <p style="margin: 0 0 5px 0; font-size: 10px; color: #666;"><strong>Connected to:</strong></p>
                                 ${connectedRuns.map(conn => `
                                     <div style="margin: 2px 0; font-size: 10px;">
                                         <span style="color: #3498db;">${conn.id}</span>
                                         ${conn.keywords.length > 0 ? `<span style="color: #666;"> (${conn.keywords.length} shared)</span>` : ''}
                                     </div>
                                 `).join('')}
                                 ${connections > 3 ? `<p style="margin: 2px 0; font-size: 10px; color: #999;">... and ${connections - 3} more</p>` : ''}
                             </div>
                         ` : ''}
                     </div>
                 `;
             });

             html += `
                     </div>

                     <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                         <h4 style="margin: 0 0 10px 0; color: #2c3e50;">Connection Analysis</h4>
                         <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                             <div style="padding: 10px; background: white; border-radius: 4px;">
                                 <p style="margin: 0; font-size: 10px;"><strong>Most Connected:</strong> ${getMostConnectedRun()}</p>
                             </div>
                             <div style="padding: 10px; background: white; border-radius: 4px;">
                                 <p style="margin: 0; font-size: 10px;"><strong>Highest Completion:</strong> ${getHighestCompletionRun()}</p>
                             </div>
                             <div style="padding: 10px; background: white; border-radius: 4px;">
                                 <p style="margin: 0; font-size: 10px;"><strong>Most Keywords:</strong> ${getMostKeywordsRun()}</p>
                             </div>
                         </div>
                     </div>
                 </div>
             `;

             canvas.innerHTML = html;
         }

         function getMostConnectedRun() {
             const connectionCounts = {};
             graphData.edges.forEach(edge => {
                 connectionCounts[edge.source] = (connectionCounts[edge.source] || 0) + 1;
                 connectionCounts[edge.target] = (connectionCounts[edge.target] || 0) + 1;
             });
             const mostConnected = Object.entries(connectionCounts).reduce((a, b) => a[1] > b[1] ? a : b);
             return mostConnected ? mostConnected[0] : 'None';
         }

         function getHighestCompletionRun() {
             const highest = graphData.nodes.reduce((a, b) => a.completion > b.completion ? a : b);
             return highest ? `${highest.label} (${highest.completion}%)` : 'None';
         }

                 function getMostKeywordsRun() {
            const mostKeywords = graphData.nodes.reduce((a, b) => a.keywords.size > b.keywords.size ? a : b);
            return mostKeywords ? `${mostKeywords.label} (${mostKeywords.size})` : 'None';
        }

        // Column dragging functionality
        function makeColumnsDraggable() {
            const table = document.querySelector('#comparison-table-container table');
            if (!table) return;

            const headerRow = table.querySelector('thead tr');
            const headerCells = headerRow.querySelectorAll('th');

            // Drag handles removed for cleaner display
            headerCells.forEach(headerCell => {
                // Remove existing event listeners by cloning the element
                const newHeaderCell = headerCell.cloneNode(true);
                headerCell.parentNode.replaceChild(newHeaderCell, headerCell);
            });

            // Get fresh reference after cloning
            const freshHeaderCells = table.querySelectorAll('thead th');

            // Add drag handles and make headers draggable
            freshHeaderCells.forEach((headerCell, index) => {
                if (index === 0) return; // Skip the first column (Keyword/Run Version column)

                // Add drag handle
                const dragHandle = document.createElement('div');
                                    dragHandle.innerHTML = '::';
                dragHandle.style.cssText = `
                    position: absolute;
                    top: 2px;
                    right: 2px;
                    cursor: move;
                    font-size: 10px;
                    color: #666;
                    user-select: none;
                    padding: 2px;
                    z-index: 10;
                `;
                dragHandle.className = 'column-drag-handle';

                // Make header cell relative positioned for drag handle
                headerCell.style.position = 'relative';
                headerCell.appendChild(dragHandle);

                // Add drag event listeners
                headerCell.draggable = true;
                headerCell.dataset.columnIndex = index;

                headerCell.addEventListener('dragstart', handleDragStart);
                headerCell.addEventListener('dragover', handleDragOver);
                headerCell.addEventListener('drop', handleDrop);
                headerCell.addEventListener('dragenter', handleDragEnter);
                headerCell.addEventListener('dragleave', handleDragLeave);
            });
        }

        let draggedColumn = null;
        let draggedColumnIndex = null;

        function handleDragStart(e) {
            draggedColumn = e.target;
            draggedColumnIndex = parseInt(e.target.dataset.columnIndex);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);

            // Add visual feedback
            e.target.style.opacity = '0.5';
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (e.target.tagName === 'TH' && e.target !== draggedColumn) {
                e.target.style.borderLeft = '3px solid #3498db';
            }
        }

        function handleDragLeave(e) {
            if (e.target.tagName === 'TH') {
                e.target.style.borderLeft = '';
            }
        }

        function handleDrop(e) {
            e.preventDefault();

            if (e.target.tagName === 'TH' && e.target !== draggedColumn) {
                const targetColumnIndex = parseInt(e.target.dataset.columnIndex);

                // Remove visual feedback
                draggedColumn.style.opacity = '';
                e.target.style.borderLeft = '';

                // Reorder columns
                reorderColumns(draggedColumnIndex, targetColumnIndex);
            }
        }

        function reorderColumns(fromIndex, toIndex) {
            const table = document.querySelector('#comparison-table-container table');
            if (!table) return;

            const rows = table.querySelectorAll('tr');

            rows.forEach(row => {
                const cells = row.querySelectorAll('td, th');
                if (cells.length <= Math.max(fromIndex, toIndex)) return;

                // Get the cell to move
                const cellToMove = cells[fromIndex];

                if (fromIndex < toIndex) {
                    // Moving right: insert after target
                    row.insertBefore(cellToMove, cells[toIndex + 1]);
                } else {
                    // Moving left: insert before target
                    row.insertBefore(cellToMove, cells[toIndex]);
                }
            });

            // Update column indices
            updateColumnIndices();

            // Show success message
            showColumnReorderMessage(`Column moved from position ${fromIndex + 1} to ${toIndex + 1}`);
        }

        function updateColumnIndices() {
            const table = document.querySelector('#comparison-table-container table');
            if (!table) return;

            const headerCells = table.querySelectorAll('thead th');
            headerCells.forEach((headerCell, index) => {
                headerCell.dataset.columnIndex = index;
            });
        }

        function showColumnReorderMessage(message) {
            // Create or update message element
            let messageElement = document.getElementById('column-reorder-message');
            if (!messageElement) {
                messageElement = document.createElement('div');
                messageElement.id = 'column-reorder-message';
                messageElement.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #27ae60;
                    color: white;
                    padding: 10px 15px;
                    border-radius: 4px;
                    font-size: 10px;
                    z-index: 1000;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(messageElement);
            }

            messageElement.textContent = message;
            messageElement.style.opacity = '1';

            // Hide message after 3 seconds
            setTimeout(() => {
                messageElement.style.opacity = '0';
                setTimeout(() => {
                    if (messageElement.parentNode) {
                        messageElement.parentNode.removeChild(messageElement);
                    }
                }, 300);
            }, 3000);
        }

        function resetColumnOrder() {
            // Get current keyword selection
            let selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
                .map(checkbox => checkbox.value);

            // If no keywords selected, try to restore from stored state
            if (selectedKeywords.length === 0 && window.lastSelectedKeywords) {
                selectedKeywords = window.lastSelectedKeywords;
                // Restore checkbox states
                document.querySelectorAll('.keyword-checkbox').forEach(checkbox => {
                    checkbox.checked = selectedKeywords.includes(checkbox.value);
                });
            }

            if (selectedKeywords.length > 0) {
                if (isTransposed) {
                    // Reset transposed view with current selection
                    showTransposedComparison(currentComparisonRuns, selectedKeywords);
                } else {
                    // Reset normal view with current selection
                    showComparisonTableOnly(selectedKeywords);
                }
                showColumnReorderMessage('Column order reset to original');
            } else {
                alert('No keywords selected. Please select keywords first.');
            }
        }

        function validateComparisonInterface() {
            // Check if all required elements exist
            const comparisonSection = document.getElementById('comparison-section');
            const comparisonContent = document.getElementById('comparison-content');
            const comparisonTableContainer = document.getElementById('comparison-table-container');
            const comparisonControls = document.getElementById('comparison-controls');
            const keywordCheckboxes = document.querySelectorAll('.keyword-checkbox');

            // Basic validation
            if (!comparisonSection || !comparisonContent) {
                return false;
            }

            // Check if interface has content
            if (comparisonContent.children.length === 0) {
                return false;
            }

            // Check if keyword checkboxes exist
            if (keywordCheckboxes.length === 0) {
                return false;
            }

            return true;
        }

        function showComparisonTableOnly(selectedKeywords = null) {
            // Use provided selectedKeywords or get from checkboxes
            if (!selectedKeywords) {
                selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
                    .map(checkbox => checkbox.value);

                if (selectedKeywords.length === 0) {
                    // Check if we have stored selection state
                    if (window.lastSelectedKeywords && window.lastSelectedKeywords.length > 0) {
                        selectedKeywords = window.lastSelectedKeywords;
                        // Restore checkbox states
                        document.querySelectorAll('.keyword-checkbox').forEach(checkbox => {
                            checkbox.checked = selectedKeywords.includes(checkbox.value);
                        });
                    } else {
                        // Fallback: select all keywords
                        selectAllKeywords();
                        selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
                            .map(checkbox => checkbox.value);
                    }
                }
            }

            // Store current selection for future use
            window.lastSelectedKeywords = selectedKeywords;

            // Ensure the comparison section is visible
            const comparisonSection = document.getElementById('comparison-section');
            if (comparisonSection.style.display === 'none') {
                comparisonSection.style.display = 'block';
            }

            // Check if comparison interface exists, if not recreate it
            const comparisonContent = document.getElementById('comparison-content');
            if (!comparisonContent || comparisonContent.children.length === 0) {
                // Recreate the comparison interface
                showComparison(currentComparisonRuns);
                return;
            }

            // Show the comparison table container and controls
            document.getElementById('comparison-table-container').style.display = 'block';
            document.getElementById('comparison-controls').style.display = 'block';

            // Populate the table with selected keywords
            populateComparisonTable(selectedKeywords);

            // Update the keyword count
            updateKeywordCount();
        }

        function exportGraphImage() {
            const canvas = document.getElementById('graph-canvas');
            html2canvas(canvas).then(canvas => {
                const link = document.createElement('a');
                link.download = `hawkeye-graph-${new Date().toISOString().split('T')[0]}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        }

        // Test function to verify graph functionality
        function testGraph() {
            console.log('Testing graph functionality...');
            console.log('D3.js available:', typeof d3 !== 'undefined');
            console.log('Current view:', currentView);
            console.log('Graph data:', graphData);

            if (currentView === 'graph') {
                const canvas = document.getElementById('graph-canvas');
                console.log('Graph canvas:', canvas);
                console.log('Canvas content:', canvas.innerHTML);
            }
        }
    </script>

    <script>
        // Keyboard shortcuts for main dashboard
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + F: Focus search
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                const searchInput = document.getElementById('run-version-search');
                if (searchInput) searchInput.focus();
            }

            // Ctrl/Cmd + E: Export
            if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                e.preventDefault();
                exportCSV();
            }

            // Escape: Clear filters
            if (e.key === 'Escape') {
                const searchInput = document.getElementById('run-version-search');
                if (searchInput && searchInput.value) {
                    clearFilters();
                }
            }

            // Ctrl/Cmd + A: Select all runs
            if ((e.ctrlKey || e.metaKey) && e.key === 'a' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                selectAllRuns();
            }
        });
    </script>

    <!-- D3.js for graph visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Check if D3.js loaded successfully
        if (typeof d3 === 'undefined') {
            console.warn('D3.js failed to load from CDN, trying alternative source...');
            // Try alternative CDN
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js';
            script.onload = function() {
                console.log('D3.js loaded from alternative CDN');
            };
            script.onerror = function() {
                console.warn('D3.js failed to load from all CDNs, using fallback visualization');
            };
            document.head.appendChild(script);
        }
    </script>

    <!-- html2canvas for graph export -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

    <!-- Minimal D3.js fallback if CDN fails -->
    <script>
        // Create a minimal D3.js-like object if the real D3.js fails to load
        if (typeof d3 === 'undefined') {
            console.log('Creating minimal D3.js fallback');
            window.d3 = {
                forceSimulation: function(nodes) {
                    return {
                        force: function() { return this; },
                        on: function() { return this; }
                    };
                },
                forceLink: function() {
                    return {
                        id: function() { return this; },
                        distance: function() { return this; }
                    };
                },
                forceManyBody: function() {
                    return {
                        strength: function() { return this; }
                    };
                },
                forceCenter: function() { return {}; },
                forceCollide: function() {
                    return {
                        radius: function() { return this; }
                    };
                },
                select: function() {
                    return {
                        selectAll: function() {
                            return {
                                data: function() {
                                    return {
                                        enter: function() {
                                            return {
                                                append: function() {
                                                    return {
                                                        attr: function() { return this; },
                                                        style: function() { return this; },
                                                        on: function() { return this; },
                                                        text: function() { return this; }
                                                    };
                                                }
                                            };
                                        }
                                    };
                                }
                            };
                        }
                    };
                }
            };
        }
    </script>
</body>
</html>
