===== FILE: ./__init__.py =====


===== FILE: ./Package__init__.py =====
# treem_casino/__init__.py
"""
Treem Casino - Enhanced Directory Management Application
A modern, type-safe directory browser with memo system and advanced operations.
"""

__version__ = "2.0.0"
__author__ = "Casino Project Team"
__description__ = "Enhanced directory management with modern PyQt5 architecture"

from .config.settings import AppConfig

# treem_casino/config/__init__.py
"""Configuration management module."""

from .settings import AppConfig, ColorScheme, FontConfig, PathConfig, UIConfig

__all__ = ['AppConfig', 'ColorScheme', 'FontConfig', 'PathConfig', 'UIConfig']

# treem_casino/models/__init__.py
"""Data models for the application."""

from .directory import DirectoryHierarchy, DirectoryInfo, DirectoryFilter, SearchResult
from .memo import Memo, MemoCollection, MemoStats

__all__ = [
    'DirectoryHierarchy', 'DirectoryInfo', 'DirectoryFilter', 'SearchResult',
    'Memo', 'MemoCollection', 'MemoStats'
]

# treem_casino/services/__init__.py
"""Business logic services."""

from .directory_service import DirectoryService
from .memo_service import MemoService

__all__ = ['DirectoryService', 'MemoService']

# treem_casino/ui/__init__.py
"""User interface components."""

from .main_window import MainWindow
from .widgets import (
    EnhancedTreeView, BlinkingDelegate, ProgressWidget, SearchWidget,
    MemoDialog, MemoViewerDialog, StatusWidget, FilterControlWidget,
    DepthControlWidget, ConfirmationDialog
)
from .dialogs import CloneDialog

__all__ = [
    'MainWindow', 'EnhancedTreeView', 'BlinkingDelegate', 'ProgressWidget',
    'SearchWidget', 'MemoDialog', 'MemoViewerDialog', 'StatusWidget',
    'FilterControlWidget', 'DepthControlWidget', 'ConfirmationDialog',
    'CloneDialog'
]

# treem_casino/utils/__init__.py
"""Utility modules."""

from .tree_model import DirectoryTreeModel, TreeItem
from .logger import setup_logging, get_logger

__all__ = ['DirectoryTreeModel', 'TreeItem', 'setup_logging', 'get_logger']


===== FILE: ./config/__init__.py =====


===== FILE: ./config/settings.py =====
"""
Configuration management for Treem Casino application.
Centralizes all settings, colors, and configuration options.
"""

import os
from dataclasses import dataclass, field
from typing import Dict, Any, Tuple
from pathlib import Path


@dataclass
class ColorScheme:
    """Application color scheme configuration."""

    # Primary colors from original
    olive: str = "#778a35"
    sage_green: str = "#d1e2c4"
    pewter: str = "#ebebe8"
    olive_green: str = "#31352e"
    ivory: str = "#EBECE0"
    white: str = "#F7F8F8"

    # Accent colors
    dark_blue: str = "#051537"
    chili_pepper: str = "#BC3110"
    burnt_sienna: str = "#BE6310"
    blue_grotto: str = "#43B0F1"
    scarlet: str = "#88070B"
    ebony: str = "#32291C"
    tan: str = "#856536"

    # UI specific colors
    background: str = "#ebebe8"
    tree_background: str = "#F7F8F8"
    button_primary: str = "#778a35"
    button_secondary: str = "#d1e2c4"
    button_danger: str = "#88070B"
    button_warning: str = "#BC3110"

    # Text colors
    text_primary: str = "black"
    text_secondary: str = "#31352e"
    text_highlight: str = "brown"
    text_accent: str = "blue"
    text_pattern_match: str = "#045AB7"


@dataclass
class FontConfig:
    """Font configuration for the application."""

    primary_family: str = "Terminus"
    primary_size: int = 12
    secondary_size: int = 8

    def get_font_tuple(self, size: int = None) -> Tuple[str, int]:
        """Get font tuple for Qt font creation."""
        return (self.primary_family, size or self.primary_size)


@dataclass
class PathConfig:
    """Path configuration for the application."""

    def __post_init__(self):
        """Initialize paths from environment variables."""
        self.project_base = Path(os.getenv('casino_prj_base', ''))
        self.project_name = os.getenv('casino_prj_name', '')
        self.base_directory = self.project_base / self.project_name

        # Design environment variables
        self.design_ver = os.getenv('casino_design_ver', '')
        self.dk_ver = os.getenv('casino_dk_ver', '')
        self.tag = os.getenv('casino_tag', '')

        # Shared directory for memos
        self.shared_dir = self.project_base / "shared" if self.project_base else Path.home()
        self.memo_file = self.shared_dir / "directory_memos.yaml"


@dataclass
class UIConfig:
    """UI-specific configuration."""

    # Window settings
    default_width: int = 600
    default_height: int = 300
    minimum_width: int = 400
    minimum_height: int = 300

    # Tree view settings
    tree_minimum_height: int = 400
    max_directory_depth: int = 6
    initial_scan_depth: int = 3  # NEW: Only scan 3 levels initially for speed

    # Terminal settings
    terminal_geometry: str = "120x40"
    terminal_bg_color: str = "#0c0c1e"
    terminal_fg_color: str = "#e2e8f0"

    # Button sizes
    button_spacing: int = 5
    depth_button_width: int = 65

    # Timing
    blink_interval: int = 500
    file_watch_delay: int = 100

    # NEW: Performance settings
    fast_scan_mode: bool = True  # Skip expensive metadata checks during refresh
    lazy_load_metadata: bool = True  # Load metadata only when needed
    skip_empty_checks: bool = True  # Don't check if directories are empty

@dataclass
class AppConfig:
    """Main application configuration container."""

    colors: ColorScheme = field(default_factory=ColorScheme)
    fonts: FontConfig = field(default_factory=FontConfig)
    paths: PathConfig = field(default_factory=PathConfig)
    ui: UIConfig = field(default_factory=UIConfig)

    # Application metadata
    app_name: str = "Treem Casino"
    version: str = "2.0.0"

    # Feature flags
    enable_async_operations: bool = True
    enable_search: bool = True
    enable_dark_mode: bool = False
    enable_plugins: bool = False

    def get_environment_pattern(self) -> str:
        """Get the environment pattern for highlighting."""
        if all([self.paths.design_ver, self.paths.dk_ver, self.paths.tag]):
            return f"{self.paths.design_ver}_{self.paths.dk_ver}_{self.paths.tag}"
        return ""

    def get_user_workspace_pattern(self) -> str:
        """Get the user workspace pattern."""
        import getpass
        return f"works_{getpass.getuser()}"

    def ensure_shared_directory(self) -> bool:
        """Ensure shared directory exists with proper permissions."""
        try:
            self.paths.shared_dir.mkdir(mode=0o775, parents=True, exist_ok=True)

            # Try to set group ownership if possible
            if self.paths.project_base.exists():
                try:
                    import stat
                    project_stat = self.paths.project_base.stat()
                    os.chown(
                        self.paths.shared_dir,
                        -1,
                        project_stat.st_gid
                    )
                except (OSError, AttributeError):
                    pass  # Ignore if we can't set group ownership

            return True
        except Exception as e:
            print(f"Warning: Could not create shared directory: {e}")
            return False


# Global configuration instance
config = AppConfig()


===== FILE: ./models/__init__.py =====


===== FILE: ./models/memo.py =====
"""
Data models for memo system.
Provides type-safe representations of directory memos and metadata.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime
import getpass


@dataclass
class Memo:
    """Represents a memo attached to a directory."""

    text: str
    user: str = field(default_factory=getpass.getuser)
    timestamp: datetime = field(default_factory=datetime.now)
    tags: List[str] = field(default_factory=list)
    category: Optional[str] = None
    priority: int = 0  # 0=normal, 1=high, -1=low

    @property
    def formatted_timestamp(self) -> str:
        """Get formatted timestamp string."""
        return self.timestamp.strftime("%Y-%m-%d %H:%M")

    @property
    def is_current_user(self) -> bool:
        """Check if memo belongs to current user."""
        return self.user == getpass.getuser()

    def to_dict(self) -> Dict:
        """Convert memo to dictionary for serialization."""
        return {
            'text': self.text,
            'user': self.user,
            'timestamp': self.formatted_timestamp,
            'tags': self.tags,
            'category': self.category,
            'priority': self.priority
        }

    @classmethod
    def from_dict(cls, data) -> 'Memo':
        """Create memo from dictionary."""
        # Handle legacy format and new format
        if isinstance(data, str):
            # Legacy format: just a string
            return cls(text=data, user="unknown", timestamp=datetime.now())

        # Handle timestamp parsing
        timestamp_str = data.get('timestamp', '')
        try:
            timestamp = datetime.strptime(timestamp_str, "%Y-%m-%d %H:%M")
        except (ValueError, TypeError):
            timestamp = datetime.now()

        return cls(
            text=data.get('text', ''),
            user=data.get('user', 'unknown'),
            timestamp=timestamp,
            tags=data.get('tags', []),
            category=data.get('category'),
            priority=data.get('priority', 0)
        )

    def update_text(self, new_text: str):
        """Update memo text and timestamp."""
        self.text = new_text
        self.timestamp = datetime.now()
        self.user = getpass.getuser()


@dataclass
class MemoCollection:
    """Collection of memos with management capabilities."""

    memos: Dict[Path, Memo] = field(default_factory=dict)

    def add_memo(self, path: Path, memo):
        """Add or update a memo for a directory."""
        if isinstance(memo, str):
            memo = Memo(text=memo)
        self.memos[path] = memo

    def get_memo(self, path: Path) -> Optional[Memo]:
        """Get memo for a directory."""
        return self.memos.get(path)

    def remove_memo(self, path: Path) -> bool:
        """Remove memo for a directory."""
        if path in self.memos:
            del self.memos[path]
            return True
        return False

    def has_memo(self, path: Path) -> bool:
        """Check if directory has a memo."""
        return path in self.memos

    def get_all_paths_with_memos(self) -> List[Path]:
        """Get all directory paths that have memos."""
        return list(self.memos.keys())

    def search_memos(self, query: str) -> List[Path]:
        """Search for directories with memos containing query."""
        results = []
        query_lower = query.lower()

        for path, memo in self.memos.items():
            if query_lower in memo.text.lower():
                results.append(path)

        return results

    def to_dict(self) -> Dict:
        """Convert collection to dictionary for serialization."""
        return {
            str(path): memo.to_dict()
            for path, memo in self.memos.items()
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'MemoCollection':
        """Create collection from dictionary."""
        collection = cls()

        for path_str, memo_data in data.items():
            path = Path(path_str)
            memo = Memo.from_dict(memo_data)
            collection.memos[path] = memo

        return collection

    def cleanup_invalid_paths(self) -> int:
        """Remove memos for paths that no longer exist."""
        invalid_paths = [
            path for path in self.memos.keys()
            if not path.exists()
        ]

        for path in invalid_paths:
            del self.memos[path]

        return len(invalid_paths)


===== FILE: ./models/directory.py =====
"""
Data models for directory and file system operations.
Provides type-safe representations of directory hierarchies and metadata.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Union, Any
from datetime import datetime
import os
import stat



@dataclass
class DirectoryInfo:
    """Information about a single directory."""

    path: Path
    name: str = field(init=False)
    size: Optional[int] = None
    modified_time: Optional[datetime] = None
    permissions: Optional[str] = None
    is_symlink: bool = False
    is_empty: bool = False
    _metadata_loaded: bool = field(default=False, init=False)

    def __post_init__(self):
        """Initialize computed fields."""
        self.name = self.path.name
        # Don't load metadata by default - do it lazily
        # self._update_metadata()

    def _update_metadata(self, check_empty: bool = False):
        """Update directory metadata from filesystem.

        Args:
            check_empty: If True, check if directory is empty (expensive operation)
        """
        try:
            if self.path.exists():
                stat_info = self.path.stat()
                self.modified_time = datetime.fromtimestamp(stat_info.st_mtime)
                self.permissions = stat.filemode(stat_info.st_mode)
                self.is_symlink = self.path.is_symlink()

                # Only check if directory is empty when explicitly requested
                if check_empty and self.path.is_dir():
                    try:
                        self.is_empty = not any(self.path.iterdir())
                    except PermissionError:
                        self.is_empty = False

                self._metadata_loaded = True
        except (OSError, PermissionError):
            pass  # Keep defaults if we can't access the directory

    def ensure_metadata_loaded(self, check_empty: bool = False):
        """Ensure metadata is loaded, load if not already loaded."""
        if not self._metadata_loaded:
            self._update_metadata(check_empty=check_empty)

    @property
    def display_name(self) -> str:
        """Get display name with empty indicator if needed."""
        # Only show empty indicator if we actually checked
        if self._metadata_loaded and self.is_empty:
            return f"{self.name} (Empty)"
        return self.name

    def refresh(self, check_empty: bool = False):
        """Refresh metadata from filesystem."""
        self._metadata_loaded = False
        self._update_metadata(check_empty=check_empty)

@dataclass
class DirectoryHierarchy:
    """Represents a hierarchical directory structure."""

    root: DirectoryInfo
    children: Dict[Path, 'DirectoryHierarchy'] = field(default_factory=dict)
    depth: int = 0
    max_depth: int = 6

    @classmethod
    def from_path(
        cls,
        path: Path,
        max_depth: int = 6,
        current_depth: int = 0
    ) -> 'DirectoryHierarchy':
        """Create hierarchy from a filesystem path."""
        root_info = DirectoryInfo(path)
        hierarchy = cls(
            root=root_info,
            depth=current_depth,
            max_depth=max_depth
        )

        if current_depth < max_depth:
            hierarchy._load_children()

        return hierarchy

    def _load_children(self):
        """Load child directories."""
        if not self.root.path.is_dir():
            return

        try:
            for child_path in self.root.path.iterdir():
                if child_path.is_dir() and not child_path.is_symlink():
                    try:
                        child_hierarchy = DirectoryHierarchy.from_path(
                            child_path,
                            self.max_depth,
                            self.depth + 1
                        )
                        self.children[child_path] = child_hierarchy
                    except (OSError, PermissionError):
                        continue  # Skip inaccessible directories
        except (OSError, PermissionError):
            pass  # Can't read directory

    def get_all_paths(self) -> List[Path]:
        """Get all directory paths in the hierarchy."""
        paths = [self.root.path]
        for child in self.children.values():
            paths.extend(child.get_all_paths())
        return paths

    def find_directory(self, target_path: Path) -> Optional['DirectoryHierarchy']:
        """Find a specific directory in the hierarchy."""
        if self.root.path == target_path:
            return self

        for child in self.children.values():
            result = child.find_directory(target_path)
            if result:
                return result

        return None

    def calculate_max_depth(self) -> int:
        """Calculate the maximum depth of this hierarchy."""
        if not self.children:
            return self.depth

        return max(child.calculate_max_depth() for child in self.children.values())

    def filter_by_pattern(self, pattern: str) -> List[Path]:
        """Find directories matching a pattern."""
        matches = []

        if pattern in self.root.name:
            matches.append(self.root.path)

        for child in self.children.values():
            matches.extend(child.filter_by_pattern(pattern))

        return matches

    def refresh(self):
        """Refresh the entire hierarchy from filesystem."""
        self.root.refresh()

        # Clear and reload children
        self.children.clear()
        if self.depth < self.max_depth:
            self._load_children()


@dataclass
class DirectoryFilter:
    """Filter configuration for directory listings."""

    show_only_user_workspace: bool = False
    user_name: Optional[str] = None
    allowed_directories: List[str] = field(default_factory=list)
    sort_by: str = "mtime"  # "mtime" or "name"
    pattern_highlight: Optional[str] = None
    environment_pattern: Optional[str] = None

    def __post_init__(self):
        """Set default allowed directories."""
        if not self.allowed_directories:
            self.allowed_directories = ["FastTrack", "dbs", "outfeeds"]

    def should_include(self, directory_info: DirectoryInfo) -> bool:
        """Determine if a directory should be included based on filter."""
        if not self.show_only_user_workspace:
            return True

        if self.user_name:
            user_workspace = f"works_{self.user_name}"
            if directory_info.name == user_workspace:
                return True

        return directory_info.name in self.allowed_directories

    def get_sort_key(self, directory_info: DirectoryInfo) -> Any:
        """Get sort key for a directory."""
        is_works = directory_info.name.startswith("works_")

        if self.sort_by == "mtime":
            mtime = directory_info.modified_time
            if mtime:
                key_val = -mtime.timestamp()  # Negative for reverse order
            else:
                key_val = 0
        else:  # sort by name
            key_val = directory_info.name.lower()

        # Works directories first, then by sort criteria
        return (0 if is_works else 1, key_val)


@dataclass
class SearchResult:
    """Result from directory search operation."""

    path: Path
    name: str
    match_type: str  # "name", "pattern", "memo"
    relevance_score: float = 0.0
    context: Optional[str] = None

    def __post_init__(self):
        """Set name from path if not provided."""
        if not self.name:
            self.name = self.path.name


===== FILE: ./services/memo_service.py =====
"""
Memo service for managing directory memos.
Handles persistent storage, real-time sync, and memo operations.
"""

import yaml
from pathlib import Path
from typing import Dict, List, Optional
from PyQt5.QtCore import QObject, pyqtSignal, QFileSystemWatcher, QTimer

from ..models.memo import Memo, MemoCollection
from ..config.settings import AppConfig


class MemoService(QObject):
    """Service for managing directory memos with real-time synchronization."""

    # Signals
    memo_added = pyqtSignal(Path, Memo)
    memo_updated = pyqtSignal(Path, Memo)
    memo_removed = pyqtSignal(Path)
    memos_loaded = pyqtSignal(MemoCollection)
    sync_error = pyqtSignal(str)

    def __init__(self, config: AppConfig):
        super().__init__()
        self.config = config
        self.memo_collection = MemoCollection()
        self.file_watcher = QFileSystemWatcher()

        # Timer for debouncing file changes
        self.sync_timer = QTimer()
        self.sync_timer.setSingleShot(True)
        self.sync_timer.timeout.connect(self._reload_memos)

        # Setup file watching
        self._setup_file_watcher()

        # Load initial memos
        self.load_memos()

    def _setup_file_watcher(self):
        """Setup file system watcher for memo file."""
        memo_dir = self.config.paths.memo_file.parent

        # Ensure directory exists
        self.config.ensure_shared_directory()

        # Watch directory and file
        if memo_dir.exists():
            self.file_watcher.addPath(str(memo_dir))
            if self.config.paths.memo_file.exists():
                self.file_watcher.addPath(str(self.config.paths.memo_file))

        # Connect signals
        self.file_watcher.directoryChanged.connect(self._on_file_changed)
        self.file_watcher.fileChanged.connect(self._on_file_changed)

    def _on_file_changed(self, path: str):
        """Handle file system changes with debouncing."""
        # Debounce file changes to avoid multiple rapid reloads
        self.sync_timer.start(self.config.ui.file_watch_delay)

    def load_memos(self) -> bool:
        """Load memos from file."""
        try:
            if self.config.paths.memo_file.exists():
                with open(self.config.paths.memo_file, 'r', encoding='utf-8') as f:
                    data = yaml.safe_load(f) or {}

                self.memo_collection = MemoCollection.from_dict(data)
                self.memos_loaded.emit(self.memo_collection)
                return True
            else:
                # Initialize empty collection
                self.memo_collection = MemoCollection()
                self.memos_loaded.emit(self.memo_collection)
                return True

        except Exception as e:
            self.sync_error.emit(f"Error loading memos: {e}")
            return False

    def _reload_memos(self):
        """Reload memos from file (called by timer)."""
        try:
            if self.config.paths.memo_file.exists():
                with open(self.config.paths.memo_file, 'r', encoding='utf-8') as f:
                    data = yaml.safe_load(f) or {}

                new_collection = MemoCollection.from_dict(data)

                # Check for changes and emit appropriate signals
                self._detect_changes(new_collection)

                self.memo_collection = new_collection
        except Exception as e:
            self.sync_error.emit(f"Error reloading memos: {e}")

    def _detect_changes(self, new_collection: MemoCollection):
        """Detect changes between old and new memo collections."""
        old_paths = set(self.memo_collection.memos.keys())
        new_paths = set(new_collection.memos.keys())

        # Detect added memos
        for path in new_paths - old_paths:
            self.memo_added.emit(path, new_collection.memos[path])

        # Detect removed memos
        for path in old_paths - new_paths:
            self.memo_removed.emit(path)

        # Detect updated memos
        for path in old_paths & new_paths:
            old_memo = self.memo_collection.memos[path]
            new_memo = new_collection.memos[path]

            if old_memo.to_dict() != new_memo.to_dict():
                self.memo_updated.emit(path, new_memo)

    def save_memos(self) -> bool:
        """Save memos to file."""
        try:
            # Temporarily remove file watcher to avoid triggering our own changes
            if self.config.paths.memo_file.exists():
                self.file_watcher.removePath(str(self.config.paths.memo_file))

            # Ensure directory exists
            self.config.ensure_shared_directory()

            # Save memos
            with open(self.config.paths.memo_file, 'w', encoding='utf-8') as f:
                yaml.dump(
                    self.memo_collection.to_dict(),
                    f,
                    default_flow_style=False,
                    sort_keys=False,
                    allow_unicode=True
                )

            # Re-add file watcher
            if self.config.paths.memo_file.exists():
                self.file_watcher.addPath(str(self.config.paths.memo_file))

            return True

        except Exception as e:
            # Ensure watcher is re-added even on error
            if self.config.paths.memo_file.exists():
                self.file_watcher.addPath(str(self.config.paths.memo_file))

            self.sync_error.emit(f"Error saving memos: {e}")
            return False

    def add_memo(self, path: Path, text: str) -> bool:
        """Add or update a memo for a directory."""
        try:
            memo = Memo(text=text)
            self.memo_collection.add_memo(path, memo)

            if self.save_memos():
                self.memo_added.emit(path, memo)
                return True
            return False

        except Exception as e:
            self.sync_error.emit(f"Error adding memo: {e}")
            return False

    def update_memo(self, path: Path, text: str) -> bool:
        """Update an existing memo."""
        try:
            existing_memo = self.memo_collection.get_memo(path)
            if existing_memo:
                existing_memo.update_text(text)
            else:
                # Create new memo if it doesn't exist
                memo = Memo(text=text)
                self.memo_collection.add_memo(path, memo)

            if self.save_memos():
                self.memo_updated.emit(path, self.memo_collection.get_memo(path))
                return True
            return False

        except Exception as e:
            self.sync_error.emit(f"Error updating memo: {e}")
            return False

    def remove_memo(self, path: Path) -> bool:
        """Remove a memo for a directory."""
        try:
            if self.memo_collection.remove_memo(path):
                if self.save_memos():
                    self.memo_removed.emit(path)
                    return True
            return False

        except Exception as e:
            self.sync_error.emit(f"Error removing memo: {e}")
            return False

    def get_memo(self, path: Path) -> Optional[Memo]:
        """Get memo for a directory."""
        return self.memo_collection.get_memo(path)

    def has_memo(self, path: Path) -> bool:
        """Check if directory has a memo."""
        return self.memo_collection.has_memo(path)

    def search_memos(self, query: str) -> List[Path]:
        """Search for directories with memos containing query."""
        return self.memo_collection.search_memos(query)

    def get_all_memo_paths(self) -> List[Path]:
        """Get all directory paths that have memos."""
        return self.memo_collection.get_all_paths_with_memos()


===== FILE: ./services/change_detection_service.py =====
"""
Service for detecting directory changes between refreshes.
Tracks modification times and identifies newly updated directories.
"""

from pathlib import Path
from typing import Dict, List, Set, Optional
from datetime import datetime
from dataclasses import dataclass
from PyQt5.QtCore import QObject, pyqtSignal

from ..models.directory import DirectoryHierarchy


@dataclass
class DirectoryChange:
    """Represents a change in a directory."""
    path: Path
    old_mtime: Optional[datetime]
    new_mtime: datetime
    change_type: str  # "new", "modified", "unchanged"

    @property
    def is_updated(self) -> bool:
        """Check if directory was updated."""
        return self.change_type in ("new", "modified")


class ChangeDetectionService(QObject):
    """Service for detecting directory changes."""

    # Signals
    changes_detected = pyqtSignal(list)  # List[DirectoryChange]

    def __init__(self):
        super().__init__()
        self.previous_state: Dict[Path, datetime] = {}
        self.current_changes: List[DirectoryChange] = []

    def capture_state(self, hierarchy: DirectoryHierarchy) -> Dict[Path, datetime]:
        """Capture current state of directory hierarchy."""
        state = {}
        self._capture_recursive(hierarchy, state)
        return state

    def _capture_recursive(self, hierarchy: DirectoryHierarchy, state: Dict[Path, datetime]):
        """Recursively capture directory modification times."""
        dir_info = hierarchy.root
        if dir_info.modified_time:
            state[dir_info.path] = dir_info.modified_time

        for child in hierarchy.children.values():
            self._capture_recursive(child, state)

    def detect_changes(self, new_hierarchy: DirectoryHierarchy) -> List[DirectoryChange]:
        """Detect changes between previous and new state."""
        new_state = self.capture_state(new_hierarchy)
        changes = []

        # Find new and modified directories
        for path, new_mtime in new_state.items():
            old_mtime = self.previous_state.get(path)

            if old_mtime is None:
                # New directory
                change = DirectoryChange(
                    path=path,
                    old_mtime=None,
                    new_mtime=new_mtime,
                    change_type="new"
                )
                changes.append(change)
            elif new_mtime > old_mtime:
                # Modified directory
                change = DirectoryChange(
                    path=path,
                    old_mtime=old_mtime,
                    new_mtime=new_mtime,
                    change_type="modified"
                )
                changes.append(change)

        # Store current changes and state
        self.current_changes = changes
        self.previous_state = new_state

        # Emit signal
        if changes:
            self.changes_detected.emit(changes)

        return changes

    def get_updated_directories(self) -> List[Path]:
        """Get list of updated directory paths."""
        return [change.path for change in self.current_changes if change.is_updated]

    def clear_changes(self):
        """Clear stored changes."""
        self.current_changes.clear()

    def reset_state(self):
        """Reset the entire state."""
        self.previous_state.clear()
        self.current_changes.clear()


===== FILE: ./services/__init__.py =====
from .change_detection_service import ChangeDetectionService
__all__ = ['DirectoryService', 'MemoService', 'ChangeDetectionService']


===== FILE: ./services/history_service.py =====
"""
Complete directory history service for tracking navigation and operations.
Provides back/forward navigation and operation history with terminal operation tracking.
History files are stored in the casino project directory with user-specific naming.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Optional, Dict, Any
from datetime import datetime
from PyQt5.QtCore import QObject, pyqtSignal
import json
import getpass

from ..config.settings import AppConfig


@dataclass
class HistoryEntry:
    """Represents a single history entry with terminal operation support and user tracking."""

    path: Path
    timestamp: datetime
    operation: str = "navigate"  # navigate, clone, create_run, trash, restore, delete, terminal
    details: Optional[str] = None
    user: str = field(default_factory=getpass.getuser)  # Track which user created the entry

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'path': str(self.path),
            'timestamp': self.timestamp.isoformat(),
            'operation': self.operation,
            'details': self.details,
            'user': self.user
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'HistoryEntry':
        """Create from dictionary."""
        return cls(
            path=Path(data['path']),
            timestamp=datetime.fromisoformat(data['timestamp']),
            operation=data.get('operation', 'navigate'),
            details=data.get('details'),
            user=data.get('user', 'unknown')
        )

    @property
    def display_name(self) -> str:
        """Get display name for history entry."""
        name = self.path.name if self.path.name else str(self.path)
        if self.operation != "navigate":
            return f"{name} ({self.operation})"
        return name

    @property
    def tooltip_text(self) -> str:
        """Get tooltip text for history entry."""
        time_str = self.timestamp.strftime("%Y-%m-%d %H:%M:%S")
        base_text = f"{self.operation.title()}: {self.path}\nTime: {time_str}\nUser: {self.user}"
        if self.details:
            base_text += f"\nDetails: {self.details}"
        return base_text

    @property
    def is_terminal_operation(self) -> bool:
        """Check if this is a terminal operation."""
        return self.operation == "terminal"


class DirectoryHistoryService(QObject):
    """Service for managing directory navigation and operation history with user-specific project storage."""

    # Signals
    history_changed = pyqtSignal()
    current_changed = pyqtSignal(Path, str)  # path, operation

    def __init__(self, config: AppConfig, max_history: int = 50):
        super().__init__()
        self.config = config
        self.max_history = max_history
        self.current_user = getpass.getuser()

        # History storage
        self.history: List[HistoryEntry] = []
        self.current_index: int = -1

        # Load user-specific history
        self.load_history()

    def get_history_file_path(self) -> Path:
        """Get user-specific history file path in project directory."""
        # Use project base directory: $casino_prj_base/$casino_prj_name
        if self.config.paths.base_directory.exists():
            # Store in project directory with user-specific filename
            return self.config.paths.base_directory / f".directory_history_{self.current_user}.json"
        else:
            # Fallback to user's home directory if project directory doesn't exist
            return Path.home() / f".treem_casino_history_{self.current_user}.json"

    def add_entry(self, path: Path, operation: str = "navigate", details: Optional[str] = None):
        """Add a new history entry with user information."""
        # Convert string path to Path object
        if isinstance(path, str):
            path = Path(path)

        # Don't add duplicate consecutive entries for navigation
        if (self.history and self.current_index >= 0 and
            self.current_index < len(self.history) and
            operation == "navigate" and
            self.history[self.current_index].path == path and
            self.history[self.current_index].operation == "navigate"):
            return

        # Create new entry with current user
        entry = HistoryEntry(
            path=path,
            timestamp=datetime.now(),
            operation=operation,
            details=details,
            user=self.current_user
        )

        # If we're in the middle of history, remove everything after current position
        if self.current_index < len(self.history) - 1:
            self.history = self.history[:self.current_index + 1]

        # Add new entry
        self.history.append(entry)
        self.current_index = len(self.history) - 1

        # Trim history if too long
        if len(self.history) > self.max_history:
            removed_count = len(self.history) - self.max_history
            self.history = self.history[removed_count:]
            self.current_index -= removed_count

        # Save and emit signals
        self.save_history()
        self.history_changed.emit()
        self.current_changed.emit(path, operation)

    def can_go_back(self) -> bool:
        """Check if we can go back in history."""
        return self.current_index > 0

    def can_go_forward(self) -> bool:
        """Check if we can go forward in history."""
        return self.current_index < len(self.history) - 1

    def go_back(self) -> Optional[HistoryEntry]:
        """Go back one step in history."""
        if self.can_go_back():
            self.current_index -= 1
            entry = self.history[self.current_index]
            self.history_changed.emit()
            self.current_changed.emit(entry.path, "navigate_back")
            return entry
        return None

    def go_forward(self) -> Optional[HistoryEntry]:
        """Go forward one step in history."""
        if self.can_go_forward():
            self.current_index += 1
            entry = self.history[self.current_index]
            self.history_changed.emit()
            self.current_changed.emit(entry.path, "navigate_forward")
            return entry
        return None

    def get_current_entry(self) -> Optional[HistoryEntry]:
        """Get current history entry."""
        if 0 <= self.current_index < len(self.history):
            return self.history[self.current_index]
        return None

    def get_back_entries(self, count: int = 10) -> List[HistoryEntry]:
        """Get recent back entries for dropdown menu."""
        if self.current_index <= 0:
            return []

        start_idx = max(0, self.current_index - count)
        return self.history[start_idx:self.current_index][::-1]  # Reverse for recent first

    def get_forward_entries(self, count: int = 10) -> List[HistoryEntry]:
        """Get forward entries for dropdown menu."""
        if self.current_index >= len(self.history) - 1:
            return []

        end_idx = min(len(self.history), self.current_index + count + 1)
        return self.history[self.current_index + 1:end_idx]

    def get_recent_operations(self, operation_type: str = None, count: int = 10, user_only: bool = True) -> List[HistoryEntry]:
        """Get recent operations of a specific type, optionally filtered by current user."""
        entries = []
        history_to_check = self.get_user_entries_only() if user_only else self.history

        for entry in reversed(history_to_check):
            if operation_type is None or entry.operation == operation_type:
                entries.append(entry)
                if len(entries) >= count:
                    break
        return entries

    def get_user_entries_only(self) -> List[HistoryEntry]:
        """Get only entries created by current user."""
        return [entry for entry in self.history if entry.user == self.current_user]

    def get_operation_history(self) -> List[HistoryEntry]:
        """Get all non-navigation operations."""
        return [entry for entry in self.history if entry.operation != "navigate"]

    def jump_to_entry(self, entry: HistoryEntry) -> bool:
        """Jump to a specific history entry."""
        try:
            index = self.history.index(entry)
            self.current_index = index
            self.history_changed.emit()
            self.current_changed.emit(entry.path, "navigate_jump")
            return True
        except ValueError:
            return False

    def clear_history(self):
        """Clear all history."""
        self.history.clear()
        self.current_index = -1
        self.save_history()
        self.history_changed.emit()

    def save_history(self):
        """Save user-specific history to project directory."""
        try:
            history_file = self.get_history_file_path()
            history_file.parent.mkdir(parents=True, exist_ok=True)

            # Save with user and project metadata
            data = {
                'user': self.current_user,
                'project_base': str(self.config.paths.project_base),
                'project_name': self.config.paths.project_name,
                'history': [entry.to_dict() for entry in self.history],
                'current_index': self.current_index,
                'saved_at': datetime.now().isoformat(),
                'version': '2.0'
            }

            with open(history_file, 'w') as f:
                json.dump(data, f, indent=2)

            print(f"Saved {len(self.history)} history entries for user {self.current_user} to {history_file}")

        except Exception as e:
            print(f"Warning: Could not save history for user {self.current_user}: {e}")

    def load_history(self):
        """Load user-specific history from project directory."""
        try:
            history_file = self.get_history_file_path()
            if not history_file.exists():
                print(f"No history file found for user {self.current_user} at {history_file}")
                # Try to migrate from old shared location
                self.migrate_shared_history()
                return

            with open(history_file, 'r') as f:
                data = json.load(f)

            # Verify this history belongs to current user
            saved_user = data.get('user', 'unknown')
            if saved_user != self.current_user:
                print(f"Warning: History file belongs to {saved_user}, not {self.current_user}")
                # Start fresh for security
                return

            # Load history entries
            self.history = [HistoryEntry.from_dict(entry_data) for entry_data in data.get('history', [])]
            self.current_index = data.get('current_index', -1)

            # Validate current_index
            if self.current_index >= len(self.history):
                self.current_index = len(self.history) - 1

            print(f"Loaded {len(self.history)} history entries for user {self.current_user}")

        except Exception as e:
            print(f"Warning: Could not load history for user {self.current_user}: {e}")
            self.history = []
            self.current_index = -1

    def migrate_shared_history(self):
        """Migrate from old shared history location to project-specific location."""
        # Try old shared directory location
        old_shared_file = self.config.paths.shared_dir / "directory_history.json"
        if old_shared_file.exists():
            self._migrate_from_file(old_shared_file)
            return

        # Try old home directory location
        old_home_file = Path.home() / ".treem_casino_history.json"
        if old_home_file.exists():
            self._migrate_from_file(old_home_file)

    def _migrate_from_file(self, old_file: Path):
        """Migrate history from an old file location."""
        try:
            with open(old_file, 'r') as f:
                old_data = json.load(f)

            # Filter entries for current user or entries without user info
            old_entries = old_data.get('history', [])
            user_entries = []

            for entry_data in old_entries:
                entry = HistoryEntry.from_dict(entry_data)
                # Include entries that belong to current user or have no user info (legacy)
                if entry.user == self.current_user or entry.user == 'unknown':
                    entry.user = self.current_user  # Claim legacy entries
                    user_entries.append(entry)

            if user_entries:
                self.history = user_entries
                self.current_index = len(self.history) - 1
                self.save_history()
                print(f"Migrated {len(user_entries)} entries from {old_file} to user-specific project history")

        except Exception as e:
            print(f"Warning: Could not migrate history from {old_file}: {e}")

    # Operation-specific methods
    def add_navigation(self, path: Path):
        """Add navigation entry."""
        self.add_entry(path, "navigate")

    def add_terminal_operation(self, path: Path):
        """Add terminal operation entry with special details."""
        details = f"GoGoGo terminal opened at {path.name}"
        self.add_entry(path, "terminal", details)

    def add_clone_operation(self, source_path: Path, dest_path: Path):
        """Add clone operation entry."""
        details = f"Cloned to: {dest_path.name}"
        self.add_entry(source_path, "clone", details)
        # Also add navigation to destination
        self.add_entry(dest_path, "navigate")

    def add_create_run_operation(self, run_path: Path):
        """Add create run directory operation."""
        details = f"Created run directory: {run_path.name}"
        self.add_entry(run_path.parent, "create_run", details)
        # Also add navigation to new run directory
        self.add_entry(run_path, "navigate")

    def add_trash_operation(self, paths: List[Path], trash_path: Path):
        """Add trash operation entry."""
        details = f"Moved {len(paths)} items to trash"
        # Add entry for the parent directory where items were moved from
        if paths:
            self.add_entry(paths[0].parent, "trash", details)
        # Add navigation to trash bin
        self.add_entry(trash_path, "navigate")

    def add_restore_operation(self, paths: List[Path]):
        """Add restore operation entry."""
        details = f"Restored {len(paths)} items from trash"
        if paths:
            # Add entry for trash bin
            trash_bin = paths[0].parent
            self.add_entry(trash_bin, "restore", details)
            # Add navigation to restored location
            restored_location = trash_bin.parent
            self.add_entry(restored_location, "navigate")

    def add_delete_operation(self, paths: List[Path]):
        """Add delete operation entry with specific directory names."""
        if not paths:
            return

        # Create detailed list of deleted directories
        deleted_names = [path.name for path in paths]

        if len(deleted_names) == 1:
            details = f"Permanently deleted: {deleted_names[0]}"
        elif len(deleted_names) <= 3:
            details = f"Permanently deleted: {', '.join(deleted_names)}"
        else:
            details = f"Permanently deleted: {', '.join(deleted_names[:3])}, and {len(deleted_names) - 3} more"

        self.add_entry(paths[0].parent, "delete", details)


===== FILE: ./services/directory_service.py =====
"""
Fixed directory service with proper "Me only" filtering.
"""

import os
import shutil
import subprocess
import platform
import grp
from pathlib import Path
from typing import List, Dict, Optional, Union, Callable
from datetime import datetime  # ADD THIS LINE
from PyQt5.QtCore import QObject, pyqtSignal, QThread, QTimer

from ..models.directory import DirectoryHierarchy, DirectoryFilter, DirectoryInfo, SearchResult
from ..config.settings import AppConfig


class DirectoryScanner(QThread):
    """Background thread for scanning directory hierarchies with detailed progress reporting."""

    # Signals
    progress_updated = pyqtSignal(str, int)  # message, progress_percent
    scan_completed = pyqtSignal(DirectoryHierarchy)
    scan_error = pyqtSignal(str)

    def __init__(self, base_path: Path, max_depth: int = 6, fast_mode: bool = True):
        super().__init__()
        self.base_path = base_path
        self.max_depth = max_depth
        self.fast_mode = fast_mode  # Skip expensive metadata checks
        self._cancelled = False
        self.total_dirs_estimated = 0
        self.dirs_processed = 0

    def cancel(self):
        """Cancel the scanning operation."""
        self._cancelled = True

    def _estimate_directory_count(self, path: Path, current_depth: int = 0) -> int:
        """Estimate total number of directories to scan for progress calculation."""
        if current_depth >= self.max_depth or self._cancelled:
            return 0

        count = 1  # Count current directory

        try:
            for child_path in path.iterdir():
                if self._cancelled:
                    break

                if child_path.is_dir() and not child_path.is_symlink():
                    try:
                        count += self._estimate_directory_count(child_path, current_depth + 1)
                    except (OSError, PermissionError):
                        continue
        except (OSError, PermissionError):
            pass

        return count

    def _scan_with_progress(self, path: Path, max_depth: int, current_depth: int = 0) -> DirectoryHierarchy:
        """Scan directory hierarchy with progress reporting - OPTIMIZED."""
        if self._cancelled:
            return None

        # Update progress every 10 directories to reduce signal overhead
        self.dirs_processed += 1
        if self.dirs_processed % 10 == 0 or self.dirs_processed == 1:
            progress_percent = min(95, int((self.dirs_processed / max(self.total_dirs_estimated, 1)) * 100))
            dir_name = path.name if path.name else str(path)
            depth_info = f"depth {current_depth}/{max_depth}"
            message = f"Scanning {dir_name} ({depth_info}) - {self.dirs_processed}/{self.total_dirs_estimated} dirs"
            self.progress_updated.emit(message, progress_percent)

        # Create directory info
        root_info = DirectoryInfo(path)

        # OPTIMIZED: In fast mode, skip ALL metadata loading initially
        if self.fast_mode:
            # Mark as not loaded - will lazy load on demand
            root_info._metadata_loaded = False
        else:
            # Normal mode: load metadata
            root_info.ensure_metadata_loaded(check_empty=False)

        # Create hierarchy object
        hierarchy = DirectoryHierarchy(
            root=root_info,
            depth=current_depth,
            max_depth=max_depth
        )

        # Load children if within depth limit
        if current_depth < max_depth and not self._cancelled:
            self._load_children_with_progress(hierarchy, path, current_depth)

        return hierarchy

    def _load_children_with_progress(self, hierarchy: DirectoryHierarchy, path: Path, current_depth: int):
        """Load child directories with progress reporting - OPTIMIZED with os.scandir."""
        if self._cancelled:
            return

        try:
            child_paths = []

            # OPTIMIZED: Use os.scandir() instead of pathlib - much faster!
            import os
            with os.scandir(str(path)) as entries:
                for entry in entries:
                    if self._cancelled:
                        break

                    try:
                        # os.scandir caches stat info - very fast
                        if entry.is_dir(follow_symlinks=False):
                            child_paths.append(Path(entry.path))
                    except (OSError, PermissionError):
                        continue  # Skip inaccessible entries

            # Process each child with progress updates
            for child_path in child_paths:
                if self._cancelled:
                    break

                try:
                    child_hierarchy = self._scan_with_progress(
                        child_path,
                        hierarchy.max_depth,
                        current_depth + 1
                    )
                    if child_hierarchy:
                        hierarchy.children[child_path] = child_hierarchy

                except (OSError, PermissionError):
                    continue  # Skip inaccessible directories

        except (OSError, PermissionError):
            pass  # Can't read directory

    def run(self):
        """Run the directory scanning in background with detailed progress."""
        try:
            self.progress_updated.emit("Initializing directory scan...", 0)

            if not self.base_path.exists():
                self.scan_error.emit(f"Directory does not exist: {self.base_path}")
                return

            # Skip estimation in fast mode - it's slow!
            if self.fast_mode:
                self.total_dirs_estimated = 1000  # Rough estimate to avoid division by zero
                self.progress_updated.emit("Starting fast directory scan...", 5)
            else:
                self.progress_updated.emit("Estimating scan scope...", 5)
                self.total_dirs_estimated = self._estimate_directory_count(self.base_path)

            if self._cancelled:
                return

            self.progress_updated.emit(f"Starting scan of {self.total_dirs_estimated} directories...", 10)
            self.dirs_processed = 0

            # Perform the actual scan
            hierarchy = self._scan_with_progress(
                self.base_path,
                max_depth=self.max_depth
            )

            if not self._cancelled and hierarchy:
                self.progress_updated.emit("Finalizing directory tree...", 98)
                # Small delay to show completion message
                self.msleep(200)

                self.progress_updated.emit("Directory scan completed successfully!", 100)
                self.scan_completed.emit(hierarchy)

        except Exception as e:
            if not self._cancelled:
                error_msg = f"Scan error: {str(e)}"
                self.scan_error.emit(error_msg)

class DirectoryService(QObject):
    """Service for directory operations and management."""

    # Signals
    hierarchy_updated = pyqtSignal(DirectoryHierarchy)
    operation_completed = pyqtSignal(str, bool)  # operation_name, success
    progress_updated = pyqtSignal(str, int)

    def __init__(self, config: AppConfig):
        super().__init__()
        self.config = config
        self._current_hierarchy: Optional[DirectoryHierarchy] = None
        self._scanner: Optional[DirectoryScanner] = None

    def scan_directory_async(self, base_path: Path, fast_mode: bool = True):
        """Scan directory hierarchy asynchronously.

        Args:
            base_path: Directory to scan
            fast_mode: If True, skip expensive metadata checks (much faster)
        """
        if self._scanner and self._scanner.isRunning():
            self._scanner.cancel()
            self._scanner.wait()

        self._scanner = DirectoryScanner(
            base_path,
            self.config.ui.max_directory_depth,
            fast_mode=fast_mode
        )
        self._scanner.progress_updated.connect(self.progress_updated)
        self._scanner.scan_completed.connect(self._on_scan_completed)
        self._scanner.scan_error.connect(self._on_scan_error)
        self._scanner.start()

    def _on_scan_completed(self, hierarchy: DirectoryHierarchy):
        """Handle completed directory scan."""
        self._current_hierarchy = hierarchy
        self.hierarchy_updated.emit(hierarchy)
        self.operation_completed.emit("directory_scan", True)

    def _on_scan_error(self, error: str):
        """Handle directory scan error."""
        self.operation_completed.emit(f"directory_scan_error: {error}", False)

    def get_current_hierarchy(self) -> Optional[DirectoryHierarchy]:
        """Get the current directory hierarchy."""
        return self._current_hierarchy

    # Fix for directory_service.py - apply_filter method

    def apply_filter(
        self,
        hierarchy: DirectoryHierarchy,
        filter_config: DirectoryFilter
    ) -> DirectoryHierarchy:
        """Apply filter to directory hierarchy - FIXED for Me only mode."""

        def should_include_directory(dir_info: DirectoryInfo, is_root_level: bool = False) -> bool:
            """Determine if directory should be included - FIXED logic."""
            if not filter_config.show_only_user_workspace:
                # Show all directories when "Me only" is not selected
                return True

            dir_name = dir_info.name

            # At root level, apply the "Me only" filter
            if is_root_level:
                # FIXED: Always include allowed directories (outfeeds, FastTrack, dbs)
                if dir_name in filter_config.allowed_directories:
                    return True

                # Include current user's workspace
                if filter_config.user_name:
                    user_workspace = f"works_{filter_config.user_name}"
                    if dir_name == user_workspace:
                        return True

                # FIXED: Exclude other users' workspaces but allow non-workspace directories
                # Only filter out directories that start with "works_" but are NOT the current user's
                if dir_name.startswith("works_"):
                    # This is a workspace directory
                    if filter_config.user_name:
                        user_workspace = f"works_{filter_config.user_name}"
                        return dir_name == user_workspace
                    else:
                        return False  # No user specified, hide all workspaces

                # FIXED: Allow all other directories (like hawkeye_archive, etc.)
                # The "Me only" filter should only hide OTHER USERS' works_ directories
                return True

            # For subdirectories (not root level), include everything
            return True

        def filter_hierarchy_recursive(source_hierarchy: DirectoryHierarchy, is_root: bool = False) -> DirectoryHierarchy:
            """Recursively filter hierarchy."""
            # Create filtered hierarchy
            filtered = DirectoryHierarchy(
                root=source_hierarchy.root,
                depth=source_hierarchy.depth,
                max_depth=source_hierarchy.max_depth
            )

            # Filter children
            for path, child_hierarchy in source_hierarchy.children.items():
                if should_include_directory(child_hierarchy.root, is_root):
                    # Recursively filter child
                    filtered_child = filter_hierarchy_recursive(child_hierarchy, False)
                    filtered.children[path] = filtered_child

            return filtered

        return filter_hierarchy_recursive(hierarchy, True)

    def search_directories(
        self,
        query: str,
        hierarchy: Optional[DirectoryHierarchy] = None
    ) -> List[SearchResult]:
        """Search for directories matching query."""
        if hierarchy is None:
            hierarchy = self._current_hierarchy

        if not hierarchy:
            return []

        results = []
        query_lower = query.lower()

        # Search in current directory
        if query_lower in hierarchy.root.name.lower():
            results.append(SearchResult(
                path=hierarchy.root.path,
                name=hierarchy.root.name,
                match_type="name",
                relevance_score=self._calculate_relevance(query, hierarchy.root.name)
            ))

        # Search in children
        for child in hierarchy.children.values():
            results.extend(self.search_directories(query, child))

        # Sort by relevance
        results.sort(key=lambda x: x.relevance_score, reverse=True)
        return results

    def _calculate_relevance(self, query: str, text: str) -> float:
        """Calculate relevance score for search results."""
        query_lower = query.lower()
        text_lower = text.lower()

        if text_lower == query_lower:
            return 1.0
        elif text_lower.startswith(query_lower):
            return 0.8
        elif query_lower in text_lower:
            return 0.6
        else:
            return 0.0

    def open_terminal(self, path: Path) -> bool:
        """Open terminal at specified path."""
        if platform.system() != "Linux":
            self.operation_completed.emit("Terminal opening only supported on Linux", False)
            return False

        try:
            current_gid = os.getgid()
            group_info = grp.getgrgid(current_gid)
            group_name = group_info.gr_name

            # Create terminal title
            path_parts = path.parts
            title_suffix = "/".join(path_parts[-4:]) if len(path_parts) >= 4 else str(path)
            terminal_title = f"GoGoGo - ({title_suffix})"

            # Terminal command
            terminal_command = f"cd {path}; newgrp {group_name} && exec csh"

            # Launch terminal with custom colors
            subprocess.Popen([
                "gnome-terminal",
                "--title", terminal_title,
                "--geometry", self.config.ui.terminal_geometry,
                "--working-directory", str(path),
                "--", "csh", "-c",
                f'printf "\\033]11;{self.config.ui.terminal_bg_color}\\007"; '
                f'printf "\\033]10;{self.config.ui.terminal_fg_color}\\007"; '
                f'{terminal_command}'
            ])

            self.operation_completed.emit("Terminal opened", True)
            return True

        except Exception as e:
            self.operation_completed.emit(f"terminal_error: {str(e)}", False)
            return False


===== FILE: ./ui/__init__.py =====


===== FILE: ./ui/updated_dirs_widget.py =====
"""
Widget for displaying and navigating to updated directories after refresh.
"""

from pathlib import Path
from typing import List
from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QScrollArea, QFrame
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QFont

from ..config.settings import AppConfig


class UpdatedDirectoriesWidget(QWidget):
    """Widget showing recently updated directories with navigation buttons."""

    # Signals
    navigate_requested = pyqtSignal(Path)
    cleared = pyqtSignal()

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.updated_paths: List[Path] = []
        self.setup_ui()
        self.hide()  # Hidden by default

    def setup_ui(self):
        """Setup the widget UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(3)

        # Header with title and clear button
        header_layout = QHBoxLayout()

        self.title_label = QLabel("? Updated Directories (0)")
        self.title_label.setFont(QFont(*self.config.fonts.get_font_tuple(10)))
        self.title_label.setStyleSheet("""
            color: #051537;
            font-weight: bold;
            background-color: #E8F4F8;
            padding: 4px 8px;
            border-radius: 3px;
        """)

        self.clear_button = QPushButton("Clear")
        self.clear_button.setFont(QFont(*self.config.fonts.get_font_tuple(8)))
        self.clear_button.setFixedSize(60, 22)
        self.clear_button.setStyleSheet("""
            QPushButton {
                background-color: #7B7B7B;
                color: white;
                border: none;
                border-radius: 2px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #999999;
            }
        """)
        self.clear_button.clicked.connect(self.clear_updates)

        header_layout.addWidget(self.title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.clear_button)

        layout.addLayout(header_layout)

        # Scroll area for directory buttons
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setMaximumHeight(120)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #CCCCCC;
                background-color: #FAFAFA;
                border-radius: 3px;
            }
        """)

        # Container for buttons
        self.buttons_widget = QWidget()
        self.buttons_layout = QVBoxLayout(self.buttons_widget)
        self.buttons_layout.setContentsMargins(3, 3, 3, 3)
        self.buttons_layout.setSpacing(2)
        self.buttons_layout.addStretch()

        scroll.setWidget(self.buttons_widget)
        layout.addWidget(scroll)

        # Style the main widget
        self.setStyleSheet("""
            UpdatedDirectoriesWidget {
                background-color: #F0F8FF;
                border: 2px solid #43B0F1;
                border-radius: 5px;
            }
        """)

    def set_updated_directories(self, paths: List[Path]):
        """Set the list of updated directories."""
        self.updated_paths = paths
        self.update_display()

        if paths:
            self.show()
        else:
            self.hide()

    def update_display(self):
        """Update the display of updated directories."""
        # Clear existing buttons
        while self.buttons_layout.count() > 1:  # Keep the stretch
            item = self.buttons_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Update title
        count = len(self.updated_paths)
        self.title_label.setText(f"? Updated Directories ({count})")

        # Create buttons for each updated directory
        for i, path in enumerate(self.updated_paths):
            self.add_directory_button(path, i)

    def add_directory_button(self, path: Path, index: int):
        """Add a button for a directory."""
        button_frame = QFrame()
        button_frame.setFrameStyle(QFrame.StyledPanel)
        button_frame.setStyleSheet("""
            QFrame {
                background-color: white;
                border: 1px solid #D0D0D0;
                border-radius: 3px;
                margin: 1px;
            }
            QFrame:hover {
                background-color: #E8F4F8;
                border: 1px solid #43B0F1;
            }
        """)

        frame_layout = QHBoxLayout(button_frame)
        frame_layout.setContentsMargins(5, 3, 5, 3)

        # Directory name label with path info
        dir_label = QLabel(self.format_path_display(path))
        dir_label.setFont(QFont(*self.config.fonts.get_font_tuple(9)))
        dir_label.setStyleSheet("color: #31352e; border: none;")
        dir_label.setToolTip(str(path))
        dir_label.setWordWrap(True)

        # Go button
        go_button = QPushButton("Go ?")
        go_button.setFont(QFont(*self.config.fonts.get_font_tuple(8)))
        go_button.setFixedSize(50, 20)
        go_button.setStyleSheet("""
            QPushButton {
                background-color: #43B0F1;
                color: white;
                border: none;
                border-radius: 2px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2A90D1;
            }
        """)
        go_button.clicked.connect(lambda checked, p=path: self.navigate_to_path(p))

        frame_layout.addWidget(dir_label, stretch=1)
        frame_layout.addWidget(go_button)

        self.buttons_layout.insertWidget(index, button_frame)

    def format_path_display(self, path: Path) -> str:
        """Format path for display (show last 3-4 components)."""
        parts = path.parts
        if len(parts) > 4:
            return ".../" + "/".join(parts[-4:])
        return str(path)

    def navigate_to_path(self, path: Path):
        """Navigate to a specific path."""
        self.navigate_requested.emit(path)

    def clear_updates(self):
        """Clear all updated directories."""
        self.updated_paths.clear()
        self.update_display()
        self.hide()
        self.cleared.emit()

    def has_updates(self) -> bool:
        """Check if there are any updates."""
        return len(self.updated_paths) > 0


===== FILE: ./ui/widgets.py =====
"""
Custom UI widgets for the Treem Casino application.
Provides reusable, enhanced widgets with modern styling and behavior.
"""

from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
from PyQt5.QtWidgets import (
    QTreeView, QAbstractItemView, QStyledItemDelegate, QWidget, QVBoxLayout,
    QHBoxLayout, QPushButton, QLineEdit, QLabel, QProgressBar, QTextEdit,
    QDialog, QDialogButtonBox, QMessageBox, QFrame, QSizePolicy, QScrollArea
)
from PyQt5.QtCore import Qt, QTimer, pyqtSignal, QModelIndex
from PyQt5.QtGui import QFont, QColor, QBrush, QPainter

from ..config.settings import AppConfig
from ..models.memo import Memo


class BlinkingDelegate(QStyledItemDelegate):
    """Custom delegate for blinking text effects in tree views."""

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.blink_state = True
        self.blink_texts: Set[Tuple[QModelIndex, str]] = set()

        # Setup blink timer
        self.blink_timer = QTimer()
        self.blink_timer.timeout.connect(self._toggle_blink_state)
        self.blink_timer.start(self.config.ui.blink_interval)

    def _toggle_blink_state(self):
        """Toggle blink state and update view."""
        self.blink_state = not self.blink_state
        if self.parent():
            self.parent().viewport().update()

    def add_blinking_item(self, index: QModelIndex, text_to_blink: str):
        """Add an item to the blinking set."""
        self.blink_texts.add((index, text_to_blink))

    def remove_blinking_item(self, index: QModelIndex, text_to_blink: str):
        """Remove an item from the blinking set."""
        self.blink_texts.discard((index, text_to_blink))

    def clear_blinking_items(self):
        """Clear all blinking items."""
        self.blink_texts.clear()

    def paint(self, painter: QPainter, option, index: QModelIndex):
        """Custom paint method for blinking effect."""
        text = index.data()

        # Check if this item should blink
        should_blink = any(
            expression in text for _, expression in self.blink_texts
            if _ == index
        )

        if should_blink:
            font = option.font
            font.setBold(True)
            painter.setFont(font)

            if self.blink_state:
                painter.setPen(QColor('blue'))
                painter.setBrush(QBrush(QColor('orange')))
            else:
                painter.setPen(QColor('black'))
                painter.setBrush(QBrush(QColor('white')))

        # Call parent paint method
        super().paint(painter, option, index)


class EnhancedTreeView(QTreeView):
    """Enhanced tree view with keyboard navigation and context menu support."""

    # Signals
    enter_pressed = pyqtSignal()
    selection_changed_custom = pyqtSignal(list)  # List of selected paths

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.setup_view()

    def setup_view(self):
        """Setup tree view properties."""
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.setHeaderHidden(True)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setMinimumHeight(self.config.ui.tree_minimum_height)
        self.setStyleSheet(f"background-color: {self.config.colors.tree_background};")
        self.setContextMenuPolicy(Qt.CustomContextMenu)

    def keyPressEvent(self, event):
        """Handle key press events."""
        if event.key() in (Qt.Key_Return, Qt.Key_Enter):
            self.enter_pressed.emit()
        else:
            super().keyPressEvent(event)

    def selectionChanged(self, selected, deselected):
        """Handle selection changes."""
        super().selectionChanged(selected, deselected)

        # Emit custom signal with selected paths
        selected_paths = []
        for index in self.selectedIndexes():
            path_data = index.data(Qt.UserRole)
            if path_data:
                selected_paths.append(Path(path_data))

        self.selection_changed_custom.emit(selected_paths)


class ProgressWidget(QWidget):
    """Enhanced widget for showing operation progress with better visibility."""

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.setup_ui()
        self.hide()  # Hidden by default

    def setup_ui(self):
        """Setup enhanced progress widget UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(2, 2, 2, 2)
        layout.setSpacing(2)

        # Progress message label
        self.label = QLabel("Operation in progress...")
        self.label.setFont(QFont(*self.config.fonts.get_font_tuple(9)))
        self.label.setStyleSheet("color: #31352e; font-weight: bold;")
        self.label.setWordWrap(True)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setFont(QFont(*self.config.fonts.get_font_tuple(8)))

        # Enhanced styling for better visibility
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                border: 2px solid #31352e;
                border-radius: 5px;
                background-color: #f0f0f0;
                text-align: center;
                font-weight: bold;
                color: #31352e;
                padding: 1px;
            }
            QProgressBar::chunk {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 #88aa44, stop: 1 #778a35
                );
                border-radius: 3px;
                margin: 0px;
            }
        """)

        layout.addWidget(self.label)
        layout.addWidget(self.progress_bar)

        # Optional details frame (for scan-specific information)
        self.details_frame = QFrame()
        self.details_frame.setFrameStyle(QFrame.StyledPanel)
        self.details_frame.setStyleSheet("background-color: #f8f8f8; border: 1px solid #d0d0d0;")

        details_layout = QVBoxLayout(self.details_frame)
        details_layout.setContentsMargins(5, 3, 5, 3)

        self.details_label = QLabel()
        self.details_label.setFont(QFont(*self.config.fonts.get_font_tuple(8)))
        self.details_label.setStyleSheet("color: #666; font-style: italic;")
        self.details_label.setWordWrap(True)
        details_layout.addWidget(self.details_label)

        layout.addWidget(self.details_frame)
        self.details_frame.hide()  # Hidden by default

    def show_progress(self, message: str, progress: int = 0, details: str = None):
        """Show progress with enhanced message and optional details."""
        self.label.setText(message)
        self.progress_bar.setValue(progress)

        # Set progress bar text to show percentage and operation
        progress_text = f"{progress}%"
        if progress > 0 and progress < 100:
            if "scan" in message.lower():
                progress_text = f"Scanning... {progress}%"
            elif "estimating" in message.lower():
                progress_text = f"Analyzing... {progress}%"
            elif "finalizing" in message.lower():
                progress_text = f"Completing... {progress}%"
        elif progress == 100:
            progress_text = "Complete!"

        self.progress_bar.setFormat(progress_text)

        # Show details if provided
        if details:
            self.details_label.setText(details)
            self.details_frame.show()
        else:
            self.details_frame.hide()

        self.show()

        # Ensure the widget updates immediately
        self.repaint()

    def hide_progress(self):
        """Hide progress widget."""
        self.hide()
        self.details_frame.hide()

    def update_progress(self, message: str, progress: int, details: str = None):
        """Update progress display with new values."""
        self.show_progress(message, progress, details)

    def set_scan_mode(self, enabled: bool):
        """Enable/disable scan-specific styling and behavior."""
        if enabled:
            # Scan mode: more prominent display
            self.setStyleSheet("""
                ProgressWidget {
                    background-color: #e8f4e8;
                    border: 1px solid #778a35;
                    border-radius: 3px;
                    padding: 2px;
                }
            """)
            self.label.setStyleSheet("color: #2d4a1a; font-weight: bold;")
        else:
            # Normal mode
            self.setStyleSheet("")
            self.label.setStyleSheet("color: #31352e; font-weight: bold;")


class ScanProgressWidget(ProgressWidget):
    """Specialized progress widget for directory scanning operations."""

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(config, parent)
        self.total_estimated = 0
        self.current_count = 0
        self.scan_start_time = None

    def start_scan(self, base_path: str, estimated_dirs: int = 0):
        """Start scan progress tracking."""
        import time
        self.scan_start_time = time.time()
        self.total_estimated = estimated_dirs
        self.current_count = 0

        self.set_scan_mode(True)

        if estimated_dirs > 0:
            details = f"Scanning {estimated_dirs} directories from {Path(base_path).name}"
        else:
            details = f"Scanning directories from {Path(base_path).name}"

        self.show_progress("Initializing directory scan...", 0, details)

    def update_scan_progress(self, message: str, dirs_processed: int, current_dir: str = None):
        """Update scan progress with directory-specific information."""
        self.current_count = dirs_processed

        if self.total_estimated > 0:
            progress = min(95, int((dirs_processed / self.total_estimated) * 100))
        else:
            # Fallback progress calculation
            progress = min(90, int(dirs_processed / 10))

        # Create detailed message
        detailed_message = message
        if current_dir:
            detailed_message += f"\nCurrent: {current_dir}"

        # Calculate ETA if we have enough data
        eta_text = ""
        if self.scan_start_time and dirs_processed > 5 and self.total_estimated > 0:
            import time
            elapsed = time.time() - self.scan_start_time
            rate = dirs_processed / elapsed
            remaining = self.total_estimated - dirs_processed
            if rate > 0:
                eta_seconds = int(remaining / rate)
                if eta_seconds > 60:
                    eta_text = f" (ETA: {eta_seconds//60}m {eta_seconds%60}s)"
                elif eta_seconds > 0:
                    eta_text = f" (ETA: {eta_seconds}s)"

        details = f"Processed: {dirs_processed}"
        if self.total_estimated > 0:
            details += f"/{self.total_estimated}"
        details += eta_text

        self.show_progress(detailed_message, progress, details)

    def complete_scan(self, success: bool = True, final_message: str = None):
        """Complete the scan operation."""
        if success:
            message = final_message or "Directory scan completed successfully!"
            details = f"Total directories processed: {self.current_count}"

            if self.scan_start_time:
                import time
                elapsed = time.time() - self.scan_start_time
                if elapsed > 1:
                    details += f" in {elapsed:.1f}s"

            self.show_progress(message, 100, details)
        else:
            error_message = final_message or "Directory scan failed"
            self.show_progress(error_message, 0, "Please check the directory path and permissions")

        self.set_scan_mode(False)


class SearchWidget(QWidget):
    """Widget for directory search functionality."""

    # Signals
    search_requested = pyqtSignal(str)
    search_cleared = pyqtSignal()

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.setup_ui()

    def setup_ui(self):
        """Setup search widget UI."""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Search label
        search_label = QLabel("Search:")
        search_label.setFont(QFont(*self.config.fonts.get_font_tuple()))

        # Search input
        self.search_input = QLineEdit()
        self.search_input.setFont(QFont(*self.config.fonts.get_font_tuple(10)))
        self.search_input.setPlaceholderText("Enter directory name or pattern...")
        self.search_input.textChanged.connect(self._on_text_changed)
        self.search_input.returnPressed.connect(self._on_search_requested)

        # Search button
        self.search_button = QPushButton("Search")
        self.search_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.search_button.clicked.connect(self._on_search_requested)

        # Clear button
        self.clear_button = QPushButton("Clear")
        self.clear_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.clear_button.clicked.connect(self._on_clear_requested)
        self.clear_button.setEnabled(False)

        layout.addWidget(search_label)
        layout.addWidget(self.search_input)
        layout.addWidget(self.search_button)
        layout.addWidget(self.clear_button)

    def _on_text_changed(self, text: str):
        """Handle search text changes."""
        self.clear_button.setEnabled(bool(text))
        if not text:
            self.search_cleared.emit()

    def _on_search_requested(self):
        """Handle search request."""
        query = self.search_input.text().strip()
        if query:
            self.search_requested.emit(query)

    def _on_clear_requested(self):
        """Handle clear request."""
        self.search_input.clear()
        self.search_cleared.emit()

    def set_search_text(self, text: str):
        """Set search text programmatically."""
        self.search_input.setText(text)


class MemoDialog(QDialog):
    """Dialog for adding/editing directory memos."""

    def __init__(self, config: AppConfig, dir_path: Path, existing_memo: Optional[Memo] = None, parent=None):
        super().__init__(parent)
        self.config = config
        self.dir_path = dir_path
        self.existing_memo = existing_memo
        self.setup_ui()

    def setup_ui(self):
        """Setup memo dialog UI."""
        self.setWindowTitle("Add/Edit Memo")
        self.resize(500, 300)
        self.setFont(QFont(*self.config.fonts.get_font_tuple()))

        layout = QVBoxLayout(self)

        # Directory path label
        path_label = QLabel(f"Directory: {self.dir_path.name}")
        path_label.setWordWrap(True)
        path_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(path_label)

        # Full path label
        full_path_label = QLabel(f"Full Path: {self.dir_path}")
        full_path_label.setWordWrap(True)
        full_path_label.setStyleSheet("color: gray; font-size: 10px;")
        layout.addWidget(full_path_label)

        # Separator
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        layout.addWidget(line)

        # Memo input label
        memo_label = QLabel("Enter memo:")
        memo_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(memo_label)

        # Memo text input
        self.memo_input = QTextEdit()
        self.memo_input.setFont(QFont(*self.config.fonts.get_font_tuple(10)))

        # Set existing memo text
        if self.existing_memo:
            self.memo_input.setPlainText(self.existing_memo.text)

        layout.addWidget(self.memo_input)

        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.Save | QDialogButtonBox.Cancel
        )
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

        # Focus on text input
        self.memo_input.setFocus()

    def get_memo_text(self) -> str:
        """Get the memo text from the dialog."""
        return self.memo_input.toPlainText().strip()


class MemoViewerDialog(QDialog):
    """Dialog for viewing directory memo details."""

    def __init__(self, config: AppConfig, dir_path: Path, memo: Memo, parent=None):
        super().__init__(parent)
        self.config = config
        self.dir_path = dir_path
        self.memo = memo
        self.setup_ui()

    def setup_ui(self):
        """Setup memo viewer dialog UI."""
        self.setWindowTitle("View Memo")
        self.resize(600, 400)
        self.setFont(QFont(*self.config.fonts.get_font_tuple()))

        layout = QVBoxLayout(self)

        # Directory info
        dir_label = QLabel(f"Directory: {self.dir_path.name}")
        dir_label.setWordWrap(True)
        dir_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        layout.addWidget(dir_label)

        full_path_label = QLabel(f"Full Path: {self.dir_path}")
        full_path_label.setWordWrap(True)
        full_path_label.setStyleSheet("color: gray; font-size: 10px;")
        layout.addWidget(full_path_label)

        # Memo metadata
        metadata_text = f"Added by: {self.memo.user}\nDate: {self.memo.formatted_timestamp}"
        if self.memo.category:
            metadata_text += f"\nCategory: {self.memo.category}"
        if self.memo.tags:
            metadata_text += f"\nTags: {', '.join(self.memo.tags)}"

        metadata_label = QLabel(metadata_text)
        metadata_label.setStyleSheet("color: blue; font-size: 11px;")
        layout.addWidget(metadata_label)

        # Separator
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        layout.addWidget(line)

        # Memo content
        memo_label = QLabel("Memo:")
        memo_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(memo_label)

        memo_text_widget = QTextEdit()
        memo_text_widget.setReadOnly(True)
        memo_text_widget.setPlainText(self.memo.text)
        memo_text_widget.setStyleSheet("background-color: #f5f5f5;")
        memo_text_widget.setFont(QFont(*self.config.fonts.get_font_tuple(10)))
        layout.addWidget(memo_text_widget)

        # Close button
        button_box = QDialogButtonBox(QDialogButtonBox.Close)
        button_box.rejected.connect(self.accept)
        layout.addWidget(button_box)


class StatusWidget(QWidget):
    """Widget for displaying application status and help information."""

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.setup_ui()

    def setup_ui(self):
        """Setup status widget UI."""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Help label
        self.help_label = QLabel(
            ""
        )
        self.help_label.setFont(QFont(*self.config.fonts.get_font_tuple(8)))
        self.help_label.setStyleSheet(f"color: {self.config.colors.olive_green};")
        self.help_label.setWordWrap(True)
        self.help_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)

        # Depth status label
        self.depth_label = QLabel("Current Depth: 0/0")
        self.depth_label.setFont(QFont(*self.config.fonts.get_font_tuple(8)))
        self.depth_label.setStyleSheet("color: black;")
        self.depth_label.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Preferred)

        layout.addWidget(self.help_label, stretch=1)
        layout.addWidget(self.depth_label, stretch=0)

    def update_depth_status(self, current_depth: int, max_depth: int):
        """Update depth status display."""
        self.depth_label.setText(f"(current depth : {current_depth} / {max_depth})")

    def set_help_text(self, text: str):
        """Set help text."""
        self.help_label.setText(text)


class FilterControlWidget(QWidget):
    """Widget for directory filtering controls."""

    # Signals
    user_filter_toggled = pyqtSignal(bool)
    sort_order_changed = pyqtSignal(str)  # "mtime" or "name"

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.setup_ui()

    def setup_ui(self):
        """Setup filter control UI."""
        layout = QHBoxLayout(self)
        layout.setSpacing(self.config.ui.button_spacing)

        # Set directory label
        set_dir_label = QLabel("Set Dir:")
        set_dir_label.setFont(QFont(*self.config.fonts.get_font_tuple()))
        set_dir_label.setFixedWidth(60)
        layout.addWidget(set_dir_label)

        # User filter button
        self.user_filter_button = QPushButton("All users")
        self.user_filter_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.user_filter_button.setFixedWidth(85)
        self.user_filter_button.setCheckable(True)
        self.user_filter_button.setStyleSheet("background-color: #00493A; color: white;")
        self.user_filter_button.toggled.connect(self._on_user_filter_toggled)
        layout.addWidget(self.user_filter_button)

        # Sort order button
        self.sort_button = QPushButton("mTime")
        self.sort_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.sort_button.setFixedWidth(self.config.ui.depth_button_width)
        self.sort_button.setCheckable(True)
        self.sort_button.setChecked(True)
        self.sort_button.setStyleSheet(f"background-color: {self.config.colors.tan}; color: white;")
        self.sort_button.toggled.connect(self._on_sort_toggled)
        layout.addWidget(self.sort_button)

        # Add stretch to fill remaining space
        layout.addStretch()

    def _on_user_filter_toggled(self, checked: bool):
        """Handle user filter toggle."""
        if checked:
            self.user_filter_button.setStyleSheet(f"background-color: {self.config.colors.ebony}; color: white;")
            self.user_filter_button.setText("Me only")
        else:
            self.user_filter_button.setStyleSheet("background-color: #00493A; color: white;")
            self.user_filter_button.setText("All users")

        self.user_filter_toggled.emit(checked)

    def _on_sort_toggled(self, checked: bool):
        """Handle sort order toggle."""
        if checked:
            sort_order = "mtime"
            self.sort_button.setText("mTime")
            self.sort_button.setStyleSheet(f"background-color: {self.config.colors.tan}; color: white;")
        else:
            sort_order = "name"
            self.sort_button.setText("Name")
            self.sort_button.setStyleSheet("background-color: #A7A88A; color: black;")

        self.sort_order_changed.emit(sort_order)


class DepthControlWidget(QWidget):
    """Widget for depth level controls."""

    # Signals
    depth_level_selected = pyqtSignal(int)

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.depth_buttons: Dict[int, QPushButton] = {}
        self.current_depth = 0
        self.setup_ui()

    def setup_ui(self):
        """Setup depth control UI."""
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(2)

    def update_depth_buttons(self, max_depth: int):
        """Update depth buttons based on maximum depth."""
        # Clear existing buttons
        for button in self.depth_buttons.values():
            button.deleteLater()
        self.depth_buttons.clear()

        # Create new buttons
        for level in range(max_depth + 1):
            button = QPushButton(str(level))
            button.setFont(QFont(*self.config.fonts.get_font_tuple()))
            button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            button.setStyleSheet("background-color: #4B4B4B; color: white;")
            button.clicked.connect(lambda checked, l=level: self._on_depth_selected(l))

            self.layout.addWidget(button, stretch=1)
            self.depth_buttons[level] = button

    def _on_depth_selected(self, level: int):
        """Handle depth level selection."""
        self.current_depth = level
        self.update_button_styles()
        self.depth_level_selected.emit(level)

    def update_button_styles(self):
        """Update button styles based on current depth."""
        for level, button in self.depth_buttons.items():
            if level == self.current_depth:
                button.setStyleSheet("background-color: #4B4B4B; color: black;")
            else:
                button.setStyleSheet("background-color: #4B4B4B; color: white;")

    def set_current_depth(self, depth: int):
        """Set current depth programmatically."""
        self.current_depth = depth
        self.update_button_styles()


class ConfirmationDialog(QDialog):
    """Enhanced confirmation dialog with detailed options."""

    def __init__(self, title: str, message: str, items: List[str] = None, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.items = items or []
        self.setup_ui(message)

    def setup_ui(self, message: str):
        """Setup confirmation dialog UI."""
        layout = QVBoxLayout(self)

        # Main message
        message_label = QLabel(message)
        message_label.setWordWrap(True)
        message_label.setStyleSheet("font-weight: bold; font-size: 12px;")
        layout.addWidget(message_label)

        # Items list (if provided)
        if self.items:
            items_label = QLabel("Items:")
            items_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
            layout.addWidget(items_label)

            items_text = QTextEdit()
            items_text.setReadOnly(True)
            items_text.setMaximumHeight(150)
            items_text.setPlainText('\n'.join(self.items))
            items_text.setStyleSheet("background-color: #f5f5f5; font-size: 10px;")
            layout.addWidget(items_text)

        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.Yes | QDialogButtonBox.No
        )
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

        # Set default focus to No button for safety
        button_box.button(QDialogButtonBox.No).setDefault(True)
        button_box.button(QDialogButtonBox.No).setFocus()

    @staticmethod
    def confirm_operation(title: str, message: str, items: List[str] = None, parent=None) -> bool:
        """Static method for quick confirmation dialogs."""
        dialog = ConfirmationDialog(title, message, items, parent)
        return dialog.exec_() == QDialog.Accepted


class UpdatedDirectoriesWidget(QWidget):
    """Widget showing recently updated directories with navigation buttons."""

    # Signals
    navigate_requested = pyqtSignal(Path)
    cleared = pyqtSignal()

    def __init__(self, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.updated_paths: List[Path] = []
        self.setup_ui()
        self.hide()  # Hidden by default

    def setup_ui(self):
        """Setup the widget UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(3)

        # Header with title and clear button
        header_layout = QHBoxLayout()

        self.title_label = QLabel("? Updated Directories (0)")
        self.title_label.setFont(QFont(*self.config.fonts.get_font_tuple(10)))
        self.title_label.setStyleSheet("""
            color: #051537;
            font-weight: bold;
            background-color: #E8F4F8;
            padding: 4px 8px;
            border-radius: 3px;
        """)

        self.clear_button = QPushButton("Clear")
        self.clear_button.setFont(QFont(*self.config.fonts.get_font_tuple(8)))
        self.clear_button.setFixedSize(60, 22)
        self.clear_button.setStyleSheet("""
            QPushButton {
                background-color: #7B7B7B;
                color: white;
                border: none;
                border-radius: 2px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #999999;
            }
        """)
        self.clear_button.clicked.connect(self.clear_updates)

        header_layout.addWidget(self.title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.clear_button)

        layout.addLayout(header_layout)

        # Scroll area for directory buttons
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setMaximumHeight(120)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #CCCCCC;
                background-color: #FAFAFA;
                border-radius: 3px;
            }
        """)

        # Container for buttons
        self.buttons_widget = QWidget()
        self.buttons_layout = QVBoxLayout(self.buttons_widget)
        self.buttons_layout.setContentsMargins(3, 3, 3, 3)
        self.buttons_layout.setSpacing(2)
        self.buttons_layout.addStretch()

        scroll.setWidget(self.buttons_widget)
        layout.addWidget(scroll)

        # Style the main widget
        self.setStyleSheet("""
            UpdatedDirectoriesWidget {
                background-color: #F0F8FF;
                border: 2px solid #43B0F1;
                border-radius: 5px;
            }
        """)

    def set_updated_directories(self, paths: List[Path]):
        """Set the list of updated directories."""
        self.updated_paths = paths
        self.update_display()

        if paths:
            self.show()
        else:
            self.hide()

    def update_display(self):
        """Update the display of updated directories."""
        # Clear existing buttons
        while self.buttons_layout.count() > 1:  # Keep the stretch
            item = self.buttons_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Update title
        count = len(self.updated_paths)
        self.title_label.setText(f"? Updated Directories ({count})")

        # Create buttons for each updated directory
        for i, path in enumerate(self.updated_paths):
            self.add_directory_button(path, i)

    def add_directory_button(self, path: Path, index: int):
        """Add a button for a directory."""
        button_frame = QFrame()
        button_frame.setFrameStyle(QFrame.StyledPanel)
        button_frame.setStyleSheet("""
            QFrame {
                background-color: white;
                border: 1px solid #D0D0D0;
                border-radius: 3px;
                margin: 1px;
            }
            QFrame:hover {
                background-color: #E8F4F8;
                border: 1px solid #43B0F1;
            }
        """)

        frame_layout = QHBoxLayout(button_frame)
        frame_layout.setContentsMargins(5, 3, 5, 3)

        # Directory name label with path info
        dir_label = QLabel(self.format_path_display(path))
        dir_label.setFont(QFont(*self.config.fonts.get_font_tuple(9)))
        dir_label.setStyleSheet("color: #31352e; border: none;")
        dir_label.setToolTip(str(path))
        dir_label.setWordWrap(True)


        # Go button
        go_button = QPushButton("Go >")
        go_button.setFont(QFont(*self.config.fonts.get_font_tuple(7)))  # Smaller font size
        go_button.setFixedSize(35, 16)  # Thinner button size (width x height)
        go_button.setStyleSheet("""
            QPushButton {
                background-color: #43B0F1;
                color: white;
                border: none;
                border-radius: 2px;
                font-weight: normal;  /* Changed from bold to normal */
                padding: 0px 4px;     /* Minimal padding to keep it thin */
            }
            QPushButton:hover {
                background-color: #2A90D1;
            }
        """)


        go_button.clicked.connect(lambda checked, p=path: self.navigate_to_path(p))

        frame_layout.addWidget(dir_label, stretch=1)
        frame_layout.addWidget(go_button)

        self.buttons_layout.insertWidget(index, button_frame)

    def format_path_display(self, path: Path) -> str:
        """Format path for display (show last 3-4 components)."""
        parts = path.parts
        if len(parts) > 4:
            return ".../" + "/".join(parts[-4:])
        return str(path)

    def navigate_to_path(self, path: Path):
        """Navigate to a specific path."""
        self.navigate_requested.emit(path)

    def clear_updates(self):
        """Clear all updated directories."""
        self.updated_paths.clear()
        self.update_display()
        self.hide()
        self.cleared.emit()

    def has_updates(self) -> bool:
        """Check if there are any updates."""
        return len(self.updated_paths) > 0


===== FILE: ./ui/history_widgets.py =====
"""
Complete history navigation UI components with Go button and terminal operation styling.
"""

import getpass
from pathlib import Path
from typing import List, Optional
from PyQt5.QtWidgets import (
    QWidget, QHBoxLayout, QVBoxLayout, QPushButton, QLabel, QMenu, QAction,
    QDialog, QListWidget, QListWidgetItem, QSplitter, QTextEdit, QDialogButtonBox,
    QMessageBox, QMainWindow  # ADD THIS
)
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from PyQt5.QtGui import QFont, QIcon, QColor

from ..config.settings import AppConfig
from ..services.history_service import DirectoryHistoryService, HistoryEntry


class HistoryNavigationWidget(QWidget):
    """Widget for back/forward navigation with Go button."""

    # Signals
    navigate_requested = pyqtSignal(Path)

    def __init__(self, config: AppConfig, history_service: DirectoryHistoryService, parent=None):
        super().__init__(parent)
        self.config = config
        self.history_service = history_service
        self.setup_ui()
        self.setup_connections()

        # Initialize button states immediately
        self.update_button_states()

    def setup_ui(self):
        """Setup the navigation UI."""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)

        # Back button with dropdown
        self.back_button = QPushButton("< Back")
        self.back_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.back_button.setStyleSheet("background-color: #7B7B7B; padding: 2px 6px; color: black;")
        self.back_button.setFixedWidth(100)
        self.back_button.setEnabled(False)

        # Forward button
        self.forward_button = QPushButton("Forward >")
        self.forward_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.forward_button.setStyleSheet("background-color: #7B7B7B; padding: 2px 6px; color: black;")
        self.forward_button.setFixedWidth(100)
        self.forward_button.setEnabled(False)

        # Current location label
        self.current_label = QLabel("Current: /")
        self.current_label.setFont(QFont(*self.config.fonts.get_font_tuple(8)))
        self.current_label.setStyleSheet("color: #31352e;")
        self.current_label.setWordWrap(True)

        # History button
        self.history_button = QPushButton("History")
        self.history_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.history_button.setStyleSheet("background-color: #7B7B7B; padding: 2px 6px; color: black;")
        self.history_button.setFixedWidth(70)

        layout.addWidget(self.back_button)
        layout.addWidget(self.forward_button)
        layout.addWidget(self.current_label, stretch=1)
        layout.addWidget(self.history_button)

    def setup_connections(self):
        """Setup signal connections."""
        # Button clicks
        self.back_button.clicked.connect(self.go_back)
        self.forward_button.clicked.connect(self.go_forward)
        self.history_button.clicked.connect(self.show_history_dialog)

        # Context menus for dropdown
        self.back_button.setContextMenuPolicy(Qt.CustomContextMenu)
        self.back_button.customContextMenuRequested.connect(self.show_back_menu)

        self.forward_button.setContextMenuPolicy(Qt.CustomContextMenu)
        self.forward_button.customContextMenuRequested.connect(self.show_forward_menu)

        # Connect to history service signals
        self.history_service.history_changed.connect(self.update_button_states)
        self.history_service.current_changed.connect(self.update_current_display)

    def go_back(self):
        """Go back in history."""
        print(f"DEBUG: HistoryNavigationWidget.go_back() called")
        print(f"DEBUG: can_go_back = {self.history_service.can_go_back()}")
        print(f"DEBUG: current_index = {self.history_service.current_index}")
        print(f"DEBUG: history length = {len(self.history_service.history)}")

        if not self.history_service.can_go_back():
            print("DEBUG: Cannot go back - button should be disabled")
            return

        entry = self.history_service.go_back()
        if entry:
            print(f"DEBUG: Going back to: {entry.path}")
            self.navigate_requested.emit(entry.path)
        else:
            print("DEBUG: go_back() returned None - this shouldn't happen")

    def go_forward(self):
        """Go forward in history."""
        print(f"DEBUG: HistoryNavigationWidget.go_forward() called")
        print(f"DEBUG: can_go_forward = {self.history_service.can_go_forward()}")
        print(f"DEBUG: current_index = {self.history_service.current_index}")
        print(f"DEBUG: history length = {len(self.history_service.history)}")

        if not self.history_service.can_go_forward():
            print("DEBUG: Cannot go forward - button should be disabled")
            return

        entry = self.history_service.go_forward()
        if entry:
            print(f"DEBUG: Going forward to: {entry.path}")
            self.navigate_requested.emit(entry.path)
        else:
            print("DEBUG: go_forward() returned None - this shouldn't happen")

    def show_back_menu(self, position):
        """Show back history dropdown menu."""
        back_entries = self.history_service.get_back_entries(10)
        if not back_entries:
            print("DEBUG: No back entries for dropdown menu")
            return

        print(f"DEBUG: Showing back menu with {len(back_entries)} entries")
        menu = QMenu(self)
        for entry in back_entries:
            action = QAction(entry.display_name, self)
            action.setToolTip(entry.tooltip_text)
            action.triggered.connect(lambda checked, e=entry: self.jump_to_entry(e))
            menu.addAction(action)

        menu.exec_(self.back_button.mapToGlobal(position))

    def show_forward_menu(self, position):
        """Show forward history dropdown menu."""
        forward_entries = self.history_service.get_forward_entries(10)
        if not forward_entries:
            print("DEBUG: No forward entries for dropdown menu")
            return

        print(f"DEBUG: Showing forward menu with {len(forward_entries)} entries")
        menu = QMenu(self)
        for entry in forward_entries:
            action = QAction(entry.display_name, self)
            action.setToolTip(entry.tooltip_text)
            action.triggered.connect(lambda checked, e=entry: self.jump_to_entry(e))
            menu.addAction(action)

        menu.exec_(self.forward_button.mapToGlobal(position))

    def jump_to_entry(self, entry: HistoryEntry):
        """Jump to a specific history entry."""
        print(f"DEBUG: Jumping to history entry: {entry.path}")
        if self.history_service.jump_to_entry(entry):
            self.navigate_requested.emit(entry.path)
        else:
            print("DEBUG: Failed to jump to entry")

    def show_history_dialog(self):
        """Show full history dialog with terminal support."""
        print("DEBUG: Showing history dialog")
        dialog = HistoryViewerDialog(self.config, self.history_service, self)

        # FIXED: Get main window and connect directly to open_terminal_at_path
        main_window = None
        parent = self.parent()
        while parent:
            # Check if this is the main window by class name
            if parent.__class__.__name__ == 'MainWindow':
                main_window = parent
                break
            parent = parent.parent()

        if main_window and hasattr(main_window, 'open_terminal_at_path'):
            print("DEBUG: Successfully connected to main window's open_terminal_at_path")
            dialog.open_terminal_requested.connect(main_window.open_terminal_at_path)
        else:
            print("ERROR: Could not find main window or open_terminal_at_path method")

        if dialog.exec_() == dialog.Accepted:
            selected_entry = dialog.get_selected_entry()
            if selected_entry:
                print(f"DEBUG: Selected entry from dialog: {selected_entry.path}")
                self.jump_to_entry(selected_entry)

    def update_button_states(self):
        """Update back/forward button states."""
        can_back = self.history_service.can_go_back()
        can_forward = self.history_service.can_go_forward()

        print(f"DEBUG: Updating button states - Back: {can_back}, Forward: {can_forward}")
        print(f"DEBUG: History state - Index: {self.history_service.current_index}, Length: {len(self.history_service.history)}")

        # Enable/disable buttons
        self.back_button.setEnabled(can_back)
        self.forward_button.setEnabled(can_forward)

        # Update button styling based on state
        if can_back:
            self.back_button.setStyleSheet("background-color: #AAB7AA; padding: 2px 6px; color: black; font-weight: ;")
        else:
            self.back_button.setStyleSheet("background-color: #7B7B7B; padding: 2px 6px; color: gray;")

        if can_forward:
            self.forward_button.setStyleSheet("background-color: #AAB7AA; padding: 2px 6px; color: black; font-weight: ;")
        else:
            self.forward_button.setStyleSheet("background-color: #7B7B7B; padding: 2px 6px; color: gray;")

    def update_current_display(self, path: Path, operation: str):
        """Update current location display."""
        display_path = str(path)
        if len(display_path) > 60:
            parts = path.parts
            if len(parts) > 3:
                display_path = ".../" + "/".join(parts[-3:])

        self.current_label.setText(f"Current: {display_path}")
        self.current_label.setToolTip(f"Full path: {path}\nOperation: {operation}")

        print(f"DEBUG: Updated current display to: {display_path}")

    def debug_history_state(self):
        """Print current history state for debugging."""
        print(f"DEBUG: === History State ===")
        print(f"Current index: {self.history_service.current_index}")
        print(f"History length: {len(self.history_service.history)}")
        print(f"Can go back: {self.history_service.can_go_back()}")
        print(f"Can go forward: {self.history_service.can_go_forward()}")

        for i, entry in enumerate(self.history_service.history):
            marker = " <-- CURRENT" if i == self.history_service.current_index else ""
            print(f"  [{i}] {entry.path}{marker}")
        print(f"========================")


class HistoryViewerDialog(QDialog):
    """Dialog for viewing full history with Go buttons that open terminals."""

    # Signal for opening terminal
    open_terminal_requested = pyqtSignal(Path)

    def __init__(self, config: AppConfig, history_service: DirectoryHistoryService, parent=None):
        super().__init__(parent)
        self.config = config
        self.history_service = history_service
        self.selected_entry: Optional[HistoryEntry] = None
        self.setup_ui()
        self.populate_history()

    def setup_ui(self):
        """Setup dialog UI with Operation History below Navigation History."""
        self.setWindowTitle("Directory History")
        self.resize(800, 600)
        self.setFont(QFont(*self.config.fonts.get_font_tuple()))

        layout = QVBoxLayout(self)

        # Title
        title_label = QLabel("Directory Navigation & Operation History")
        title_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        layout.addWidget(title_label)

        # Navigation history section (top)
        nav_label = QLabel("Navigation History")
        nav_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(nav_label)

        self.nav_list = QListWidget()
        self.nav_list.setFont(QFont(*self.config.fonts.get_font_tuple(10)))
        self.nav_list.setMaximumHeight(200)  # Limit height
        layout.addWidget(self.nav_list)

        # Operation history section (bottom)
        op_label = QLabel("Operation History")
        op_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(op_label)

        self.op_list = QListWidget()
        self.op_list.setFont(QFont(*self.config.fonts.get_font_tuple(10)))
        layout.addWidget(self.op_list)

        # Details area
        details_label = QLabel("Details:")
        details_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(details_label)

        self.details_text = QTextEdit()
        self.details_text.setMaximumHeight(100)
        self.details_text.setReadOnly(True)
        self.details_text.setFont(QFont(*self.config.fonts.get_font_tuple(9)))
        self.details_text.setStyleSheet("background-color: #f5f5f5;")
        layout.addWidget(self.details_text)

        # Buttons
        button_box = QDialogButtonBox()

        self.go_button = QPushButton("Go to Selected")
        self.go_button.setEnabled(False)
        button_box.addButton(self.go_button, QDialogButtonBox.AcceptRole)

        self.clear_button = QPushButton("Clear History")
        button_box.addButton(self.clear_button, QDialogButtonBox.ResetRole)

        close_button = button_box.addButton(QDialogButtonBox.Close)

        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

        # Connect clear button directly
        self.clear_button.clicked.connect(self.clear_history)

        layout.addWidget(button_box)

        # Connect selection handlers
        self.nav_list.itemSelectionChanged.connect(self.on_nav_selection_changed)
        self.op_list.itemSelectionChanged.connect(self.on_op_selection_changed)

    def populate_history(self):
        """Populate history lists with meaningful entries and thin Go buttons."""
        # Populate navigation history - FILTER OUT base directory navigations
        self.nav_list.clear()

        # Get base directory path to filter
        base_dir = self.config.paths.base_directory

        # Filter: only show navigations that are NOT to base directory
        nav_entries = []
        for entry in self.history_service.history:
            if entry.operation == "navigate":
                # Skip if this is navigation to base directory
                if entry.path == base_dir:
                    continue
                # Skip if path is parent or grandparent (too high level)
                try:
                    if len(entry.path.relative_to(base_dir).parts) < 2:
                        continue
                except ValueError:
                    # Path not under base_dir, include it
                    pass
                nav_entries.append(entry)

        for entry in reversed(nav_entries[-50:]):
            # Create widget for item with Go button
            item_widget = QWidget()
            item_layout = QHBoxLayout(item_widget)
            item_layout.setContentsMargins(2, 2, 2, 2)
            item_layout.setSpacing(5)

            # Entry label
            entry_label = QLabel(f"{entry.path.name} - {entry.timestamp.strftime('%H:%M:%S')}")
            entry_label.setFont(QFont(*self.config.fonts.get_font_tuple(10)))

            # Thin Go button - opens terminal (text symbol only)
            go_btn = QPushButton("Go")
            go_btn.setFont(QFont(*self.config.fonts.get_font_tuple(7)))
            go_btn.setFixedSize(35, 16)
            go_btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {self.config.colors.olive};
                    padding: 0px 4px;     /* Minimal padding to keep it thin */
                    color: black;
                    border: none;
                    border-radius: 2px;
                }}
                QPushButton:hover {{
                    background-color: #88aa44;
                }}
            """)
            go_btn.clicked.connect(lambda checked, e=entry: self.open_terminal_at(e.path))
            go_btn.setToolTip(f"Open terminal at: {entry.path}")

            item_layout.addWidget(entry_label, stretch=1)
            item_layout.addWidget(go_btn)

            # Create list item
            item = QListWidgetItem(self.nav_list)
            item.setData(Qt.UserRole, entry)
            item.setSizeHint(item_widget.sizeHint())
            self.nav_list.addItem(item)
            self.nav_list.setItemWidget(item, item_widget)

        # Populate operation history
        self.op_list.clear()
        op_entries = self.history_service.get_operation_history()

        for entry in reversed(op_entries[-50:]):
            # Create widget for item with Go button
            item_widget = QWidget()
            item_layout = QHBoxLayout(item_widget)
            item_layout.setContentsMargins(2, 2, 2, 2)
            item_layout.setSpacing(5)

            # Entry label
            item_text = f"{entry.operation.title()}: {entry.path.name}"
            if entry.details:
                item_text += f" - {entry.details[:30]}..."
            item_text += f" ({entry.timestamp.strftime('%m-%d %H:%M')})"

            entry_label = QLabel(item_text)
            entry_label.setFont(QFont(*self.config.fonts.get_font_tuple(10)))

            # Color code by operation type
            if entry.operation == "clone":
                entry_label.setStyleSheet(f"color: {self.config.colors.blue_grotto};")
            elif entry.operation == "trash":
                entry_label.setStyleSheet(f"color: {self.config.colors.burnt_sienna};")
            elif entry.operation == "restore":
                entry_label.setStyleSheet(f"color: {self.config.colors.olive};")
            elif entry.operation == "delete":
                entry_label.setStyleSheet(f"color: {self.config.colors.scarlet};")
            elif entry.operation == "create_run":
                entry_label.setStyleSheet(f"color: {self.config.colors.dark_blue};")
            elif entry.operation == "terminal":
                entry_label.setStyleSheet("color: white; background-color: black; padding: 2px;")

            # Thin Go button - opens terminal
            go_btn = QPushButton("Go")
            go_btn.setFont(QFont(*self.config.fonts.get_font_tuple(7)))
            go_btn.setFixedSize(35, 16)
            go_btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {self.config.colors.olive};
                    padding: 0px 4px;     /* Minimal padding to keep it thin */
                    color: black;
                    border: none;
                    border-radius: 2px;
                }}
                QPushButton:hover {{
                    background-color: #88aa44;
                }}
            """)
            go_btn.clicked.connect(lambda checked, e=entry: self.open_terminal_at(e.path))
            go_btn.setToolTip(f"Open terminal at: {entry.path}")

            item_layout.addWidget(entry_label, stretch=1)
            item_layout.addWidget(go_btn)

            # Create list item
            item = QListWidgetItem(self.op_list)
            item.setData(Qt.UserRole, entry)
            item.setSizeHint(item_widget.sizeHint())
            self.op_list.addItem(item)
            self.op_list.setItemWidget(item, item_widget)

    def open_terminal_at(self, path: Path):
        """Open terminal at path - FIXED to actually open terminal."""
        print(f"DEBUG: Opening terminal from history dialog at: {path}")

        # Emit signal that will be caught by main window to open terminal
        self.open_terminal_requested.emit(path)

        # Dialog stays open for more operations

    def on_nav_selection_changed(self):
        """Handle navigation list selection change."""
        self.op_list.clearSelection()
        selected_items = self.nav_list.selectedItems()
        if selected_items:
            entry = selected_items[0].data(Qt.UserRole)
            self.selected_entry = entry
            self.update_details(entry)
            self.go_button.setEnabled(True)

    def on_op_selection_changed(self):
        """Handle operation list selection change."""
        self.nav_list.clearSelection()
        selected_items = self.op_list.selectedItems()
        if selected_items:
            entry = selected_items[0].data(Qt.UserRole)
            self.selected_entry = entry
            self.update_details(entry)
            self.go_button.setEnabled(True)

    def update_details(self, entry: HistoryEntry):
        """Update details display."""
        details = f"Path: {entry.path}\n"
        details += f"Operation: {entry.operation.title()}\n"
        details += f"Time: {entry.timestamp.strftime('%Y-%m-%d %H:%M:%S')}\n"
        details += f"User: {entry.user}\n"

        if entry.details:
            details += f"Details: {entry.details}\n"

        # Add additional context
        if entry.operation == "clone":
            details += "\nThis was a directory cloning operation"
        elif entry.operation == "trash":
            details += "\nItems were moved to TrashBin"
        elif entry.operation == "restore":
            details += "\nItems were restored from TrashBin"
        elif entry.operation == "delete":
            details += "\nItems were permanently deleted"
        elif entry.operation == "create_run":
            details += "\nA new run directory was created"
        elif entry.operation == "terminal":
            details += "\nGoGoGo terminal was opened at this location"

        details += "\n\nClick 'Go' button to open terminal at this location"

        self.details_text.setText(details)

    def clear_history(self):
        """Clear all history."""
        reply = QMessageBox.question(
            self,
            "Clear History",
            "Are you sure you want to clear all history?\nThis action cannot be undone.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            self.history_service.clear_history()
            self.populate_history()
            self.details_text.clear()
            self.go_button.setEnabled(False)

    def get_selected_entry(self) -> Optional[HistoryEntry]:
        """Get the selected history entry."""
        return self.selected_entry


class QuickHistoryWidget(QWidget):
    """Compact widget showing recent operations with terminal operation styling."""

    # Signals
    navigate_requested = pyqtSignal(Path)

    def __init__(self, config: AppConfig, history_service: DirectoryHistoryService, parent=None):
        super().__init__(parent)
        self.config = config
        self.history_service = history_service
        self.setup_ui()
        self.setup_connections()
        self.update_recent_operations()

    def setup_ui(self):
        """Setup compact history widget."""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Recent operations label
        self.recent_label = QLabel("Recent: ")
        self.recent_label.setFont(QFont(*self.config.fonts.get_font_tuple(8)))
        self.recent_label.setStyleSheet("color: #31352e;")
        layout.addWidget(self.recent_label)

        # Recent operation buttons (dynamic)
        self.button_layout = QHBoxLayout()
        self.button_layout.setSpacing(2)
        layout.addLayout(self.button_layout)

        layout.addStretch()

    def setup_connections(self):
        """Setup connections."""
        self.history_service.history_changed.connect(self.update_recent_operations)

    def update_recent_operations(self):
        """Update recent operation buttons with terminal operation styling."""
        # Clear existing buttons
        while self.button_layout.count():
            item = self.button_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Get recent non-navigation operations
        recent_ops = self.history_service.get_recent_operations(count=30)

        # Filter out navigation operations
        non_nav_ops = [op for op in recent_ops if op.operation != "navigate"]

        print(f"Debug: Found {len(non_nav_ops)} non-navigation operations")
        for i, op in enumerate(non_nav_ops[:10]):
            print(f"  {i+1}: {op.operation} - {op.path.name}")

        # Create buttons for recent operations - SHOW 5 operations
        for i, entry in enumerate(non_nav_ops[:10]):
            # Create shorter button text
            button_text = self._get_short_operation_text(entry)

            button = QPushButton(button_text)
            button.setFont(QFont(*self.config.fonts.get_font_tuple(7)))
            button.setMaximumHeight(20)
            button.setMaximumWidth(70)
            button.setMinimumWidth(60)

            # Enhanced tooltip with more info
            tooltip = f"{entry.operation.title()}: {entry.path.name}"
            tooltip += f"\nTime: {entry.timestamp.strftime('%m-%d %H:%M')}"
            if entry.details:
                tooltip += f"\nDetails: {entry.details}"
            button.setToolTip(tooltip)

            # Color code by operation
            button.setStyleSheet(self._get_operation_style(entry.operation))

            button.clicked.connect(lambda checked, e=entry: self._navigate_to_operation_target(e))
            self.button_layout.addWidget(button)

        if len(non_nav_ops) < 5:
            print(f"Debug: Only {len(non_nav_ops)} operations available, showing all of them")

    def _get_short_operation_text(self, entry: HistoryEntry) -> str:
        """Get shortened text for operation button."""
        operation_short = {
            "clone": "Clone",
            "trash": "Trash",
            "restore": "Restore",
            "delete": "Delete",
            "create_run": "Run",
            "navigate": "Nav",
            "terminal": "Term"
        }

        short_op = operation_short.get(entry.operation, entry.operation.title())
        dir_name = entry.path.name
        if len(dir_name) > 8:
            dir_name = dir_name[:8] + "..."

        return f"{short_op}"

    def _get_operation_style(self, operation: str) -> str:
        """Get CSS style for operation type with special terminal styling."""
        styles = {
            "clone": "background-color: #172748; color: white; font-size: 8px; padding: 2px;",
            "trash": "background-color: #172748; color: #FFFF00; font-size: 8px; padding: 2px;",
            "restore": "background-color: #7DCCFA; black: white; font-size: 8px; padding: 2px;",
            "create_run": "background-color: #051537; color: white; font-size: 8px; padding: 2px;",
            "delete": "background-color: #B53439; color: #FFFF00; font-size: 8px; padding: 2px;",
            "terminal": "background-color: black; color: white; font-size: 8px; padding: 2px; font-weight: bold;",
        }

        return styles.get(operation, "background-color: #d1e2c4; color: black; font-size: 8px; padding: 2px;")

    def _navigate_to_operation_target(self, entry: HistoryEntry):
        """Navigate to the most relevant directory for this operation."""
        target_path = entry.path

        if entry.operation == "clone":
            if entry.details and "Cloned to:" in entry.details:
                dest_name = entry.details.split("Cloned to: ")[-1]
                dest_path = entry.path.parent / dest_name
                if dest_path.exists():
                    target_path = dest_path

        elif entry.operation == "trash":
            trash_path = entry.path.parent / "TrashBin"
            if trash_path.exists():
                target_path = trash_path

        elif entry.operation == "restore":
            if "TrashBin" in str(entry.path):
                restored_location = entry.path.parent.parent
                if restored_location.exists():
                    target_path = restored_location

        elif entry.operation == "create_run":
            if entry.details and "Created run directory:" in entry.details:
                run_name = entry.details.split("Created run directory: ")[-1]
                run_path = entry.path / run_name
                if run_path.exists():
                    target_path = run_path

        elif entry.operation == "terminal":
            target_path = entry.path

        self.navigate_requested.emit(target_path)


===== FILE: ./ui/dialogs.py =====
"""
CloneDialog that matches the original implementation exactly.
"""

import os
import shutil
from pathlib import Path
from typing import Dict, Any
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QTreeWidget,
    QTreeWidgetItem, QPushButton, QProgressBar, QRadioButton, QWidget, QMessageBox
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont

from ..config.settings import AppConfig


class CloneDialog(QDialog):
    """Original CloneDialog implementation matching the attached code."""

    def __init__(self, config: AppConfig, source_path, directory_service=None, parent=None):
        super().__init__(parent)
        self.config = config

        # Convert to string for compatibility with original code
        if hasattr(source_path, '__fspath__') or isinstance(source_path, Path):
            self.dir_path = str(source_path)
        else:
            self.dir_path = source_path

        self.selected_items = {}
        self.updating_check_states = False

        # Original font setup
        font = QFont("Terminus", 10)
        self.setFont(font)
        self.setWindowTitle("Select Items to Clone")
        self.resize(400, 600)

        layout = QVBoxLayout(self)

        # Base directory label
        self.base_dir_label = QLabel("Selected Base Directory to Clone:\n" + self.dir_path)
        self.base_dir_label.setWordWrap(True)
        self.base_dir_label.setFont(font)
        self.base_dir_label.setTextInteractionFlags(Qt.TextSelectableByMouse)
        layout.addWidget(self.base_dir_label)

        # New directory name input
        label_new_dir_name = QLabel("New Directory Name for Cloned Items:")
        label_new_dir_name.setFont(font)
        layout.addWidget(label_new_dir_name)

        self.new_dir_name_input = QLineEdit()
        self.new_dir_name_input.setFont(font)
        layout.addWidget(self.new_dir_name_input)

        # Select items label
        label_select_items = QLabel("Select items to clone:")
        label_select_items.setFont(font)
        layout.addWidget(label_select_items)

        # Tree widget
        self.tree_widget = QTreeWidget()
        self.tree_widget.setFont(font)
        self.tree_widget.setHeaderLabels(["Name", "Action"])
        self.tree_widget.header().setStretchLastSection(False)
        self.tree_widget.setColumnWidth(0, int(self.width() * 0.60))
        self.tree_widget.setColumnWidth(1, int(self.width() * 0.40))
        self.tree_widget.setSelectionMode(QTreeWidget.ExtendedSelection)
        layout.addWidget(self.tree_widget)

        # Selected items label
        self.selected_items_label = QLabel("Selected Items: None")
        self.selected_items_label.setFont(font)
        layout.addWidget(self.selected_items_label)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.progress_bar.setFont(font)
        layout.addWidget(self.progress_bar)

        # Populate tree (original logic)
        self.populate_tree_original()

        # Connect signals
        self.tree_widget.itemDoubleClicked.connect(self.handle_item_double_clicked)
        self.tree_widget.itemChanged.connect(self.handle_item_checked)
        self.tree_widget.itemExpanded.connect(self.handle_item_expanded)  # ADD THIS LINE
        self.tree_widget.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree_widget.customContextMenuRequested.connect(self.show_context_menu)

        # Control buttons
        button_layout = QHBoxLayout()

        select_all_copy_button = QPushButton("Select All as Copy")
        select_all_copy_button.setFont(font)
        select_all_copy_button.clicked.connect(lambda: self.set_all_items_action("copy"))

        select_all_link_button = QPushButton("Select All as Link")
        select_all_link_button.setFont(font)
        select_all_link_button.clicked.connect(lambda: self.set_all_items_action("link"))

        select_all_button = QPushButton("Select All")
        select_all_button.setFont(font)
        select_all_button.clicked.connect(self.select_all_items)

        deselect_all_button = QPushButton("Deselect All")
        deselect_all_button.setFont(font)
        deselect_all_button.clicked.connect(self.deselect_all_items)

        expand_all_button = QPushButton("Expand All")
        expand_all_button.setFont(font)
        expand_all_button.clicked.connect(self.expand_all_items)

        button_layout.addWidget(select_all_copy_button)
        button_layout.addWidget(select_all_link_button)
        button_layout.addWidget(select_all_button)
        button_layout.addWidget(deselect_all_button)
        button_layout.addWidget(expand_all_button)

        layout.addLayout(button_layout)

        # Dialog buttons
        buttons_layout = QHBoxLayout()

        self.clone_button = QPushButton("Start Clone")
        self.clone_button.setFont(font)
        self.clone_button.setStyleSheet("background-color: #051537; color: white;")
        self.clone_button.clicked.connect(self.start_clone)

        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.setFont(font)
        self.cancel_button.clicked.connect(self.reject)

        buttons_layout.addWidget(self.clone_button)
        buttons_layout.addWidget(self.cancel_button)

        layout.addLayout(buttons_layout)

    def populate_tree_original(self):
        """Original tree population logic from the attached code."""
        def clone_sort_key(x):
            full_path = os.path.join(self.dir_path, x)
            is_works = x.startswith("works_")
            try:
                mtime = os.path.getmtime(full_path)
            except (FileNotFoundError, OSError):
                mtime = 0
            return (1 if is_works else 0, -mtime)

        try:
            items = sorted(os.listdir(self.dir_path), key=clone_sort_key)
        except (OSError, PermissionError):
            QMessageBox.warning(self, "Error", f"Cannot read directory: {self.dir_path}")
            return

        if items:
            for item_name in items:
                item_path = os.path.join(self.dir_path, item_name)
                tree_item = QTreeWidgetItem(self.tree_widget.invisibleRootItem(), [item_name])
                self.selected_items[item_path] = {'selected': False, 'action': 'copy'}
                tree_item.setData(0, Qt.UserRole, item_path)

                if os.path.isdir(item_path):
                    tree_item.setFlags(tree_item.flags() | Qt.ItemIsTristate)
                    tree_item.setCheckState(0, Qt.Unchecked)
                    try:
                        sub_items = os.listdir(item_path)
                        if sub_items:
                            self.add_directory_items(tree_item, item_path)
                        else:
                            tree_item.setText(0, f"{item_name} (Empty)")
                    except (OSError, PermissionError):
                        tree_item.setText(0, f"{item_name} (No Access)")
                else:
                    tree_item.setFlags(tree_item.flags() | Qt.ItemIsUserCheckable)
                    tree_item.setCheckState(0, Qt.Unchecked)
                    self.add_action_widget(tree_item, item_path)
        else:
            root = self.tree_widget.invisibleRootItem()
            root.setText(0, f"{os.path.basename(self.dir_path)} (Empty)")
            root.setFlags(root.flags() | Qt.ItemIsUserCheckable)
            root.setCheckState(0, Qt.Unchecked)
            self.selected_items[self.dir_path] = {'selected': False, 'action': 'create_dir'}

    def add_directory_items(self, parent_item, path):
        """Add directory items with optimized empty checking."""
        parent_item.takeChildren()
        try:
            def clone_sort_key(x):
                full_path = os.path.join(path, x)
                is_works = x.startswith("works_")
                try:
                    mtime = os.path.getmtime(full_path)
                except (FileNotFoundError, OSError):
                    mtime = 0
                return (1 if is_works else 0, -mtime)

            items = sorted(os.listdir(path), key=clone_sort_key)
            if items:
                for item_name in items:
                    item_path = os.path.join(path, item_name)
                    tree_item = QTreeWidgetItem(parent_item, [item_name])
                    self.selected_items[item_path] = {'selected': False, 'action': 'copy'}
                    tree_item.setData(0, Qt.UserRole, item_path)

                    if os.path.isdir(item_path):
                        tree_item.setFlags(tree_item.flags() | Qt.ItemIsTristate)
                        tree_item.setCheckState(0, Qt.Unchecked)

                        try:
                            # OPTIMIZATION: Use scandir with next() - stops after first item found
                            # This is much faster than os.listdir() which reads entire directory
                            with os.scandir(item_path) as entries:
                                first_entry = next(entries, None)

                            if first_entry is not None:
                                # Directory has contents - don't load children yet (lazy loading)
                                # Children will be loaded when user double-clicks or expands
                                # Create checkable dummy child so parent tristate checkbox works
                                dummy_child = QTreeWidgetItem(tree_item, ["Loading..."])
                                dummy_child.setFlags(dummy_child.flags() | Qt.ItemIsUserCheckable)
                                dummy_child.setCheckState(0, Qt.Unchecked)
                                # Store path for later loading
                                dummy_child.setData(0, Qt.UserRole, item_path)
                            else:
                                # Directory is empty
                                tree_item.setText(0, f"{item_name} (Empty)")

                        except (OSError, PermissionError):
                                tree_item.setText(0, f"{item_name} (No Access)")
                    else:
                        # It's a file
                        tree_item.setFlags(tree_item.flags() | Qt.ItemIsUserCheckable)
                        tree_item.setCheckState(0, Qt.Unchecked)
                        self.add_action_widget(tree_item, item_path)
            else:
                # Parent directory is empty
                parent_item.setText(0, f"{os.path.basename(path)} (Empty)")
                parent_item.setFlags(parent_item.flags() | Qt.ItemIsUserCheckable)
                parent_item.setCheckState(0, Qt.Unchecked)
                self.selected_items[path] = {'selected': False, 'action': 'create_dir'}

        except PermissionError:
            pass

    def set_item_action(self, path, action):
        """Original set_item_action method."""
        if path and path in self.selected_items:
            self.selected_items[path]['action'] = action

    def add_action_widget(self, tree_item, item_path):
        """Original add_action_widget method."""
        copy_radio = QRadioButton("Copy")
        link_radio = QRadioButton("Link")
        copy_radio.setChecked(True)
        copy_radio.toggled.connect(lambda checked, p=item_path: self.set_item_action(p, 'copy') if checked else None)
        link_radio.toggled.connect(lambda checked, p=item_path: self.set_item_action(p, 'link') if checked else None)

        action_widget = QWidget()
        action_layout = QHBoxLayout(action_widget)
        action_layout.addWidget(copy_radio)
        action_layout.addWidget(link_radio)
        action_layout.setContentsMargins(0, 0, 0, 0)
        action_widget.setLayout(action_layout)

        self.tree_widget.setItemWidget(tree_item, 1, action_widget)

    def handle_item_double_clicked(self, item):
            """Handle double-click with lazy loading support."""
            item_path = item.data(0, Qt.UserRole)

            if os.path.isdir(item_path):
                # Just toggle expansion - loading will be handled by handle_item_expanded
                item.setExpanded(not item.isExpanded())
            else:
                # It's a file - toggle selection
                new_state = Qt.Checked if item.checkState(0) == Qt.Unchecked else Qt.Unchecked
                self.set_subtree_check_state(item, new_state)

    def handle_item_expanded(self, item):
            """Handle item expansion - load children if needed and preserve checkbox state."""
            item_path = item.data(0, Qt.UserRole)

            if not item_path or not os.path.isdir(item_path):
                return

            # Check if this item has the dummy "Loading..." child
            if item.childCount() == 1:
                first_child = item.child(0)
                if first_child.text(0) == "Loading...":
                    # Remember parent's check state
                    parent_check_state = item.checkState(0)

                    # Remove dummy child and load actual children
                    item.removeChild(first_child)
                    self.add_directory_items(item, item_path)

                    # Restore parent's check state and propagate to children if needed
                    if parent_check_state == Qt.Checked:
                        self.set_subtree_check_state(item, Qt.Checked)
                    elif parent_check_state == Qt.PartiallyChecked:
                        # Keep partially checked state
                        item.setCheckState(0, Qt.PartiallyChecked)

    def set_subtree_check_state(self, item, state):
        """Original set_subtree_check_state method."""
        self.tree_widget.blockSignals(True)
        item.setCheckState(0, state)
        self.tree_widget.blockSignals(False)
        item_path = item.data(0, Qt.UserRole)
        if item_path in self.selected_items:
            self.selected_items[item_path]['selected'] = (state == Qt.Checked)
        for i in range(item.childCount()):
            child = item.child(i)
            self.set_subtree_check_state(child, state)
        self.update_selected_items_label()

    def handle_item_checked(self, item, column=0):
        """Original handle_item_checked method."""
        item_path = item.data(0, Qt.UserRole)
        if item_path:
            self.selected_items[item_path]['selected'] = (item.checkState(0) == Qt.Checked)
        self.update_selected_items_label()

    def update_selected_items_label(self):
        """Original update_selected_items_label method."""
        selected_count = sum(1 for info in self.selected_items.values() if info['selected'])
        self.selected_items_label.setText(f"Selected Items: {selected_count}")

    def show_context_menu(self, position):
        """Original show_context_menu method."""
        from PyQt5.QtWidgets import QMenu
        menu = QMenu()
        copy_action = menu.addAction("Set Selected as Copy")
        link_action = menu.addAction("Set Selected as Link")
        copy_action.triggered.connect(lambda: self.set_selected_action("copy"))
        link_action.triggered.connect(lambda: self.set_selected_action("link"))
        menu.exec_(self.tree_widget.viewport().mapToGlobal(position))

    def set_selected_action(self, action):
        """Original set_selected_action method."""
        for item in self.tree_widget.selectedItems():
            item_path = item.data(0, Qt.UserRole)
            if item_path in self.selected_items:
                self.selected_items[item_path]['action'] = action
            action_widget = self.tree_widget.itemWidget(item, 1)
            if action_widget:
                copy_radio, link_radio = action_widget.findChildren(QRadioButton)
                if action == 'copy':
                    copy_radio.setChecked(True)
                else:
                    link_radio.setChecked(True)

    def expand_all_items(self):
        """Original expand_all_items method."""
        root = self.tree_widget.invisibleRootItem()
        self.expand_recursive(root)

    def expand_recursive(self, item):
        """Original expand_recursive method."""
        if item.childCount() == 0 and os.path.isdir(item.data(0, Qt.UserRole)):
            self.add_directory_items(item, item.data(0, Qt.UserRole))
        item.setExpanded(True)
        for i in range(item.childCount()):
            self.expand_recursive(item.child(i))

    def set_all_items_action(self, action):
        """Original set_all_items_action method."""
        root = self.tree_widget.invisibleRootItem()
        self.apply_action_to_all(root, action)

    def apply_action_to_all(self, item, action):
        """Original apply_action_to_all method."""
        for i in range(item.childCount()):
            child = item.child(i)
            child_path = child.data(0, Qt.UserRole)
            if child_path in self.selected_items:
                self.selected_items[child_path]['action'] = action
            action_widget = self.tree_widget.itemWidget(child, 1)
            if action_widget:
                copy_radio, link_radio = action_widget.findChildren(QRadioButton)
                if action == 'copy':
                    copy_radio.setChecked(True)
                else:
                    link_radio.setChecked(True)
            self.apply_action_to_all(child, action)

    def select_all_items(self):
        """Original select_all_items method."""
        root = self.tree_widget.invisibleRootItem()
        self.set_subtree_check_state(root, Qt.Checked)
        self.update_selected_items_label()

    def deselect_all_items(self):
        """Original deselect_all_items method."""
        root = self.tree_widget.invisibleRootItem()
        self.set_subtree_check_state(root, Qt.Unchecked)
        self.update_selected_items_label()

    def start_clone(self):
        """Original start_clone method."""
        dest_dir_name = self.new_dir_name_input.text().strip()
        if not dest_dir_name:
            QMessageBox.warning(self, "Error", "Please enter a name for the cloned directory.")
            return

        parent_dir = os.path.dirname(self.dir_path)
        dest_dir_path = os.path.join(parent_dir, dest_dir_name)

        if os.path.exists(dest_dir_path):
            reply = QMessageBox.question(
                self, "Directory Exists",
                f"The directory '{dest_dir_name}' already exists. Continue and overwrite existing files?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            if reply == QMessageBox.No:
                return

        try:
            os.makedirs(dest_dir_path, exist_ok=True)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to create directory '{dest_dir_path}': {e}")
            return

        selected_items = {path: info for path, info in self.selected_items.items() if info['selected']}
        if not selected_items:
            QMessageBox.warning(self, "Error", "No items selected for cloning.")
            return

        self.progress_bar.setVisible(True)
        self.progress_bar.setMaximum(len(selected_items))
        self.progress_bar.setValue(0)
        self.progress_bar.setFormat("Cloning %p%")

        errors = []
        processed_count = 0

        for src_path, info in selected_items.items():
            try:
                relative_path = os.path.relpath(src_path, self.dir_path)
                dest_item_path = os.path.join(dest_dir_path, relative_path)

                # Skip if source and destination are the same
                if os.path.realpath(src_path) == os.path.realpath(dest_item_path):
                    print(f"Skipping {src_path} because source and destination are the same file.")
                    continue

                # Handle symlinks
                if os.path.islink(src_path):
                    # Create parent directory if needed
                    os.makedirs(os.path.dirname(dest_item_path), exist_ok=True)
                    link_target = os.readlink(src_path)
                    if not os.path.exists(dest_item_path):
                        os.symlink(link_target, dest_item_path)
                    print(f"Processing symlink: {src_path}")

                # Handle directories
                elif os.path.isdir(src_path):
                    if info['action'] == 'copy':
                        # Copy entire directory tree with all contents
                        if not os.path.exists(dest_item_path):
                            shutil.copytree(src_path, dest_item_path, symlinks=True)
                            print(f"Copied directory tree: {src_path} -> {dest_item_path}")
                        else:
                            # Directory exists, copy contents recursively
                            self._copy_directory_contents(src_path, dest_item_path)
                            print(f"Merged directory contents: {src_path} -> {dest_item_path}")
                    elif info['action'] == 'link':
                        # Create symlink to directory
                        os.makedirs(os.path.dirname(dest_item_path), exist_ok=True)
                        if not os.path.exists(dest_item_path):
                            os.symlink(src_path, dest_item_path)
                            print(f"Created directory symlink: {src_path} -> {dest_item_path}")

                # Handle regular files
                else:
                    # Create parent directory if needed
                    os.makedirs(os.path.dirname(dest_item_path), exist_ok=True)

                    if info['action'] == 'copy':
                        shutil.copy2(src_path, dest_item_path)
                        print(f"Copied file: {src_path} -> {dest_item_path}")
                    elif info['action'] == 'link':
                        if not os.path.exists(dest_item_path):
                            os.symlink(src_path, dest_item_path)
                            print(f"Created file symlink: {src_path} -> {dest_item_path}")

                processed_count += 1
                self.progress_bar.setValue(processed_count)

            except Exception as e:
                errors.append(f"Failed to process {src_path}: {e}")
                print(f"Error processing {src_path}: {e}")

        self.progress_bar.setValue(len(selected_items))

        if errors:
            QMessageBox.warning(self, "Errors Occurred", "\n".join(errors))
        else:
            QMessageBox.information(self, "Clone Completed", f"Cloning completed successfully to '{dest_dir_name}'.")

        self.progress_bar.setVisible(False)

        if not errors:
            self.accept()

    def _copy_directory_contents(self, src_dir, dest_dir):
        """Recursively copy directory contents, merging with existing destination."""
        try:
            for item in os.listdir(src_dir):
                src_item = os.path.join(src_dir, item)
                dest_item = os.path.join(dest_dir, item)

                if os.path.islink(src_item):
                    # Copy symlink
                    if not os.path.exists(dest_item):
                        link_target = os.readlink(src_item)
                        os.symlink(link_target, dest_item)

                elif os.path.isdir(src_item):
                    # Recursively copy subdirectory
                    if not os.path.exists(dest_item):
                        shutil.copytree(src_item, dest_item, symlinks=True)
                    else:
                        self._copy_directory_contents(src_item, dest_item)

                else:
                    # Copy file
                    shutil.copy2(src_item, dest_item)

        except Exception as e:
            print(f"Error copying directory contents from {src_dir} to {dest_dir}: {e}")
            raise



===== FILE: ./ui/main_window.py =====
"""
Complete main window with change detection, terminal history tracking and bottom progress bar.
"""

import getpass
import os
import shutil
from pathlib import Path
from typing import List, Optional, Dict, Any
from datetime import datetime
from PyQt5.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QLineEdit, QLabel, QApplication, QMessageBox, QMenu, QAction,
    QInputDialog
)
from PyQt5.QtCore import Qt, pyqtSlot, QTimer
from PyQt5.QtGui import QFont, QKeySequence, QClipboard

from ..config.settings import AppConfig
from ..models.directory import DirectoryHierarchy, DirectoryFilter
from ..services.directory_service import DirectoryService
from ..services.memo_service import MemoService
from ..services.history_service import DirectoryHistoryService
from ..services.change_detection_service import ChangeDetectionService, DirectoryChange
from ..ui.widgets import (
    EnhancedTreeView, BlinkingDelegate, ProgressWidget, SearchWidget,
    MemoDialog, MemoViewerDialog, StatusWidget, FilterControlWidget,
    DepthControlWidget, ConfirmationDialog, UpdatedDirectoriesWidget
)
from ..ui.history_widgets import HistoryNavigationWidget, QuickHistoryWidget
from ..utils.tree_model import DirectoryTreeModel
from ..utils.logger import get_logger


logger = get_logger(__name__)


class MainWindow(QMainWindow):
    """Main application window with change detection, terminal history tracking and bottom progress bar."""

    def __init__(self, config: AppConfig):
        """Main application window initialization."""
        super().__init__()
        self.config = config

        # Services - Initialize history service FIRST
        self.history_service = DirectoryHistoryService(config)
        self.directory_service = DirectoryService(config)
        self.memo_service = MemoService(config)
        self.change_service = ChangeDetectionService()

        # UI components
        self.tree_view: Optional[EnhancedTreeView] = None
        self.tree_model: Optional[DirectoryTreeModel] = None
        self.blinking_delegate: Optional[BlinkingDelegate] = None
        self.history_navigation: Optional[HistoryNavigationWidget] = None
        self.quick_history: Optional[QuickHistoryWidget] = None
        self.updated_dirs_widget: Optional[UpdatedDirectoriesWidget] = None

        # State
        self.current_hierarchy: Optional[DirectoryHierarchy] = None
        self.current_filter = DirectoryFilter()
        self.current_depth = 0
        self.max_depth = 0
        self.programmatic_navigation = False

        # Setup
        self.setup_ui()
        self.setup_connections()
        self.setup_shortcuts()

        # Initial load
        print(f"DEBUG: Initial refresh_directory_tree call")
        self.refresh_directory_tree()

    def setup_ui(self):
        """Setup the main user interface."""
        self.setWindowTitle("GoGoGo")
        self.resize(600, 600)
        self.setMinimumSize(400, 400)
        self.setStyleSheet(f"background-color: {self.config.colors.background};")

        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(5, 5, 5, 5)

        # Base directory input
        input_layout = QHBoxLayout()

        base_dir_label = QLabel("Base Directory:")
        base_dir_label.setFont(QFont(*self.config.fonts.get_font_tuple()))
        input_layout.addWidget(base_dir_label)

        self.base_dir_input = QLineEdit(str(self.config.paths.base_directory))
        self.base_dir_input.setFont(QFont(*self.config.fonts.get_font_tuple(8)))
        input_layout.addWidget(self.base_dir_input)

        main_layout.addLayout(input_layout)

        # History navigation
        self.history_navigation = HistoryNavigationWidget(self.config, self.history_service)
        main_layout.addWidget(self.history_navigation)

        # Tree view with custom delegate
        self.tree_view = EnhancedTreeView(self.config)
        self.blinking_delegate = BlinkingDelegate(self.config, self.tree_view)
        self.tree_view.setItemDelegate(self.blinking_delegate)
        main_layout.addWidget(self.tree_view, stretch=1)

        # Progress widget
        self.progress_widget = ProgressWidget(self.config)
        main_layout.addWidget(self.progress_widget)

        # Main action buttons
        button_layout = self.create_action_buttons()
        main_layout.addLayout(button_layout)

        # Filter and depth controls
        control_layout = QHBoxLayout()
        control_layout.setSpacing(5)

#       # Set directory label
#       set_dir_label = QLabel("Set Dir:")
#       set_dir_label.setFont(QFont(*self.config.fonts.get_font_tuple()))
#       set_dir_label.setFixedWidth(60)
#       control_layout.addWidget(set_dir_label)

        # Filter controls
        self.filter_controls = FilterControlWidget(self.config)
        control_layout.addWidget(self.filter_controls)

        # Depth controls
        self.depth_controls = DepthControlWidget(self.config)
        control_layout.addWidget(self.depth_controls, stretch=1)

        main_layout.addLayout(control_layout)

        # Quick history widget
        self.quick_history = QuickHistoryWidget(self.config, self.history_service)
        main_layout.addWidget(self.quick_history)

        # Updated directories widget
        self.updated_dirs_widget = UpdatedDirectoriesWidget(self.config)
        main_layout.addWidget(self.updated_dirs_widget)

        # Status widget
        self.status_widget = StatusWidget(self.config)
        main_layout.addWidget(self.status_widget)

        # Scan progress bar
        self.scan_progress_bar = ProgressWidget(self.config)
        self.scan_progress_bar.setMaximumHeight(35)
        self.scan_progress_bar.progress_bar.setMaximumHeight(25)
        self.scan_progress_bar.label.setFont(QFont(*self.config.fonts.get_font_tuple(9)))
        self.scan_progress_bar.progress_bar.setTextVisible(True)

        self.scan_progress_bar.progress_bar.setStyleSheet("""
            QProgressBar {
                border: 2px solid #31352e;
                border-radius: 4px;
                background-color: #ebebe8;
                text-align: center;
                font-size: 8px;
                font-weight: bold;
            }
            QProgressBar::chunk {
                background: qlineargradient(
                    x1: 0, y1: 0, x2: 0, y2: 1,
                    stop: 0 #88aa44, stop: 1 #778a35
                );
                border-radius: 2px;
            }
        """)

        main_layout.addWidget(self.scan_progress_bar)

    @pyqtSlot(Path)
    def open_terminal_at_path(self, path: Path):
        """Open terminal at specified path - called from history dialog Go buttons."""
        print(f"DEBUG: open_terminal_at_path called with: {path}")
        print(f"DEBUG: path type: {type(path)}")
        print(f"DEBUG: path exists: {path.exists()}")
        print(f"DEBUG: path is_dir: {path.is_dir()}")

        # Convert string to Path if needed
        if isinstance(path, str):
            path = Path(path)

        if not path.exists():
            print(f"ERROR: Path does not exist: {path}")
            QMessageBox.warning(self, "Invalid Path", f"Path does not exist: {path}")
            return

        if not path.is_dir():
            print(f"ERROR: Path is not a directory: {path}")
            QMessageBox.warning(self, "Invalid Path", "Selected path is not a directory.")
            return

        logger.info(f"Opening terminal from history at: {path}")

        # Add terminal opening to history
        self.history_service.add_terminal_operation(path)

        # Open terminal - same logic as Go button in main window
        print(f"DEBUG: About to call directory_service.open_terminal")
        print(f"DEBUG: directory_service exists: {self.directory_service is not None}")

        try:
            result = self.directory_service.open_terminal(path)
            print(f"DEBUG: open_terminal returned: {result}")

            if not result:
                print(f"ERROR: open_terminal returned False")
                QMessageBox.warning(self, "Terminal Error", f"Failed to open terminal at: {path}")
        except Exception as e:
            print(f"ERROR: Exception in open_terminal: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "Terminal Error", f"Exception opening terminal: {e}")

    def create_action_buttons(self) -> QHBoxLayout:
        """Create main action buttons."""
        layout = QHBoxLayout()
        layout.setSpacing(5)

        # Go button
        self.go_button = QPushButton("Go")
        self.go_button.setStyleSheet(f"background-color: {self.config.colors.olive}; color: black;")
        self.go_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.go_button.setSizePolicy(self.go_button.sizePolicy().Expanding, self.go_button.sizePolicy().Fixed)

        # Refresh button
        self.refresh_button = QPushButton("Refresh")
        self.refresh_button.setStyleSheet(f"background-color: {self.config.colors.sage_green}; color: black;")
        self.refresh_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.refresh_button.setSizePolicy(self.refresh_button.sizePolicy().Expanding, self.refresh_button.sizePolicy().Fixed)

        # Clone button
        self.clone_button = QPushButton("Clone")
        self.clone_button.setStyleSheet(f"background-color: {self.config.colors.dark_blue}; color: white;")
        self.clone_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.clone_button.setSizePolicy(self.clone_button.sizePolicy().Expanding, self.clone_button.sizePolicy().Fixed)

        # TrashBin button
        self.trash_button = QPushButton("TrashBin")
        self.trash_button.setStyleSheet(f"background-color: {self.config.colors.dark_blue}; color: yellow;")
        self.trash_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.trash_button.setSizePolicy(self.trash_button.sizePolicy().Expanding, self.trash_button.sizePolicy().Fixed)

        # Restore button
        self.restore_button = QPushButton("Restore")
        self.restore_button.setStyleSheet(f"background-color: {self.config.colors.blue_grotto}; color: black;")
        self.restore_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.restore_button.setSizePolicy(self.restore_button.sizePolicy().Expanding, self.restore_button.sizePolicy().Fixed)

        # Delete button
        self.remove_button = QPushButton("Del")
        self.remove_button.setStyleSheet(f"background-color: {self.config.colors.scarlet}; color: yellow;")
        self.remove_button.setFont(QFont(*self.config.fonts.get_font_tuple()))
        self.remove_button.setSizePolicy(self.remove_button.sizePolicy().Expanding, self.remove_button.sizePolicy().Fixed)

        # Add buttons to layout
        layout.addWidget(self.go_button)
        layout.addWidget(self.refresh_button)
        layout.addWidget(self.clone_button)
        layout.addWidget(self.trash_button)
        layout.addWidget(self.restore_button)
        layout.addWidget(self.remove_button)

        return layout

    def setup_connections(self):
        """Setup signal-slot connections."""
        # Button connections
        self.go_button.clicked.connect(self.go_to_selected_directory)
        self.refresh_button.clicked.connect(self.refresh_directory_tree)
        self.clone_button.clicked.connect(self.clone_selected_directory)
        self.trash_button.clicked.connect(self.move_selected_directory)
        self.restore_button.clicked.connect(self.restore_selected_directory)
        self.remove_button.clicked.connect(self.remove_selected_directory)

        # Tree view connections
        self.tree_view.enter_pressed.connect(self.go_to_selected_directory)
        self.tree_view.customContextMenuRequested.connect(self.show_context_menu)
        self.tree_view.selection_changed_custom.connect(self.on_selection_changed)

        # Filter connections
        self.filter_controls.user_filter_toggled.connect(self.on_user_filter_toggled)
        self.filter_controls.sort_order_changed.connect(self.on_sort_order_changed)

        # Depth connections
        self.depth_controls.depth_level_selected.connect(self.set_depth_level)

        # History navigation connections
        if hasattr(self, 'history_navigation') and self.history_navigation:
            self.history_navigation.navigate_requested.connect(self.navigate_to_path_from_history)

        if hasattr(self, 'quick_history') and self.quick_history:
            self.quick_history.navigate_requested.connect(self.navigate_to_path_from_history)

        # Change detection connections
        self.change_service.changes_detected.connect(self.on_changes_detected)
        self.updated_dirs_widget.navigate_requested.connect(self.navigate_to_path_from_update)
        self.updated_dirs_widget.cleared.connect(self.on_updates_cleared)

        # History service signals
        self.history_service.history_changed.connect(self.update_history_button_states)
        self.history_service.current_changed.connect(self.on_history_current_changed)

        # Service connections
        self.directory_service.hierarchy_updated.connect(self.on_hierarchy_updated)
        self.directory_service.operation_completed.connect(self.on_operation_completed)
        self.directory_service.progress_updated.connect(self.on_progress_updated)

        # Memo service connections
        self.memo_service.memo_added.connect(lambda path, memo: self.on_memo_changed())
        self.memo_service.memo_updated.connect(lambda path, memo: self.on_memo_changed())
        self.memo_service.memo_removed.connect(lambda path: self.on_memo_changed())
        self.memo_service.memos_loaded.connect(self.on_memos_loaded)
        self.memo_service.sync_error.connect(self.on_memo_error)

    def setup_shortcuts(self):
            """Setup keyboard shortcuts."""
            # Ctrl+V for viewing memo
            self.addAction(self.create_action("View Memo", QKeySequence("Ctrl+V"), self.view_selected_memo))

            # F5 for refresh
            self.addAction(self.create_action("Refresh", QKeySequence.Refresh, self.refresh_directory_tree))

            # Alt+Left for back
            self.addAction(self.create_action("Go Back", QKeySequence("Alt+Left"), self.go_back))

            # Alt+Right for forward
            self.addAction(self.create_action("Go Forward", QKeySequence("Alt+Right"), self.go_forward))

            # Ctrl+H for history
            self.addAction(self.create_action("Show History", QKeySequence("Ctrl+H"),
                                            lambda: self.history_navigation.show_history_dialog()))

            # ESC for clearing updates
            self.addAction(self.create_action("Clear Updates", QKeySequence(Qt.Key_Escape),
                                             lambda: self.updated_dirs_widget.clear_updates() if self.updated_dirs_widget.has_updates() else None))

            # Ctrl+1 through Ctrl+5 for depth navigation
            self.addAction(self.create_action("Set Depth 0", QKeySequence("Ctrl+0"), lambda: self.set_depth_level(0)))
            self.addAction(self.create_action("Set Depth 1", QKeySequence("Ctrl+1"), lambda: self.set_depth_level(1)))
            self.addAction(self.create_action("Set Depth 2", QKeySequence("Ctrl+2"), lambda: self.set_depth_level(2)))
            self.addAction(self.create_action("Set Depth 3", QKeySequence("Ctrl+3"), lambda: self.set_depth_level(3)))
            self.addAction(self.create_action("Set Depth 4", QKeySequence("Ctrl+4"), lambda: self.set_depth_level(4)))
            self.addAction(self.create_action("Set Depth 5", QKeySequence("Ctrl+5"), lambda: self.set_depth_level(5)))
            self.addAction(self.create_action("Set Depth 6", QKeySequence("Ctrl+6"), lambda: self.set_depth_level(6)))

    def create_action(self, name: str, shortcut: QKeySequence, slot) -> QAction:
        """Create a QAction with shortcut."""
        action = QAction(name, self)
        action.setShortcut(shortcut)
        action.triggered.connect(slot)
        return action

    @pyqtSlot()
    def go_to_selected_directory(self):
        """Open terminal at selected directory and add to recent history."""
        selected_paths = self.get_selected_paths()
        if not selected_paths:
            QMessageBox.warning(self, "No Selection", "Please select a directory.")
            return

        path = selected_paths[0]
        if not path.is_dir():
            QMessageBox.warning(self, "Invalid Selection", "Selected path is not a directory.")
            return

        logger.info(f"Opening terminal at: {path}")

        # Add terminal opening to history
        self.history_service.add_terminal_operation(path)

        # Open terminal
        self.directory_service.open_terminal(path)
        self.add_navigation_history(path)


#   @pyqtSlot(Path)
#   def open_terminal_at_path(self, path: Path):
#       """Open terminal at specified path - called from history dialog Go buttons."""
#       # Convert to Path if string
#       if isinstance(path, str):
#           path = Path(path)
#
#       # Basic validation
#       if not path.exists() or not path.is_dir():
#           return
#
#       # Use the same terminal opening logic as the main Go button
#       self.directory_service.open_terminal(path)
#       self.history_service.add_terminal_operation(path)

    @pyqtSlot(Path)
    def open_terminal_at_path(self, path: Path):
        """Open terminal at specified path - called from history dialog Go buttons."""
        if isinstance(path, str):
            path = Path(path)

        if not path.exists() or not path.is_dir():
            print(f"ERROR: Path invalid - exists: {path.exists()}, is_dir: {path.is_dir()}")
            return

        print(f"DEBUG: About to call directory_service.open_terminal")
        result = self.directory_service.open_terminal(path)
        print(f"DEBUG: open_terminal returned: {result}")

        self.history_service.add_terminal_operation(path)

    @pyqtSlot()
    def refresh_directory_tree(self):
        """Refresh the directory tree with change detection."""
        base_path = Path(self.base_dir_input.text().strip())

        if not base_path.exists():
            QMessageBox.warning(
                self,
                "Directory Not Found",
                f"The directory '{base_path}' does not exist. Please verify the path."
            )
            return

        logger.info(f"Refreshing directory tree from: {base_path}")

        # Capture current state before refresh (if we have a hierarchy)
        if self.current_hierarchy:
            logger.info("Capturing state for change detection")

        # Show scan progress immediately
        self.scan_progress_bar.show_progress("Preparing to scan directory structure...", 0)

        # Add to history ONLY if not programmatic navigation
        if not self.programmatic_navigation:
            print(f"DEBUG: refresh_directory_tree - adding {base_path} to history")
            self.add_navigation_history(base_path)
        else:
            print(f"DEBUG: refresh_directory_tree - skipping history add (programmatic)")

        # Use limited initial depth for faster loading
        initial_depth = min(self.config.ui.initial_scan_depth, self.config.ui.max_directory_depth)
        self.directory_service.scan_directory_async(base_path, fast_mode=True)

    def go_back(self):
        """Go back in history."""
        print(f"DEBUG: go_back called, can_go_back={self.history_service.can_go_back()}")

        if not self.history_service.can_go_back():
            print("DEBUG: Cannot go back - no history")
            return

        entry = self.history_service.go_back()
        if entry:
            print(f"DEBUG: Going back to {entry.path}")
            self.navigate_to_path_from_history(entry.path)
        else:
            print("DEBUG: go_back returned None")

    def go_forward(self):
        """Go forward in history."""
        print(f"DEBUG: go_forward called, can_go_forward={self.history_service.can_go_forward()}")

        if not self.history_service.can_go_forward():
            print("DEBUG: Cannot go forward - no forward history")
            return

        entry = self.history_service.go_forward()
        if entry:
            print(f"DEBUG: Going forward to {entry.path}")
            self.navigate_to_path_from_history(entry.path)
        else:
            print("DEBUG: go_forward returned None")

    def navigate_to_path_from_history(self, path: Path):
        """Navigate to a path from history."""
        print(f"DEBUG: Navigating to path from history: {path}")

        self.programmatic_navigation = True
        try:
            current_base = Path(self.base_dir_input.text())

            try:
                path.relative_to(current_base)
                print(f"DEBUG: Path {path} is under current base {current_base}")
                self.navigate_to_directory(str(path))
            except ValueError:
                print(f"DEBUG: Path {path} is NOT under current base {current_base}")
                base_path = self.find_base_path_for_target(path)
                if base_path and base_path != current_base:
                    print(f"DEBUG: Changing base directory to {base_path}")
                    self.base_dir_input.setText(str(base_path))
                    self.refresh_directory_tree()
                    QTimer.singleShot(1000, lambda: self.navigate_to_directory(str(path)))
                else:
                    print(f"DEBUG: Using fallback navigation to {path}")
                    self.navigate_to_directory(str(path))

        except Exception as e:
            print(f"DEBUG: Error in navigate_to_path_from_history: {e}")
            self.navigate_to_directory(str(path))
        finally:
            self.programmatic_navigation = False

    @pyqtSlot(Path)
    def navigate_to_path_from_update(self, path: Path):
        """Navigate to an updated directory."""
        self.programmatic_navigation = True
        try:
            current_base = Path(self.base_dir_input.text())

            try:
                path.relative_to(current_base)
                self.navigate_to_directory(str(path))
            except ValueError:
                base_path = self.find_base_path_for_target(path)
                if base_path and base_path != current_base:
                    self.base_dir_input.setText(str(base_path))
                    self.refresh_directory_tree()
                    QTimer.singleShot(1000, lambda: self.navigate_to_directory(str(path)))
                else:
                    self.navigate_to_directory(str(path))
        finally:
            self.programmatic_navigation = False

    def find_base_path_for_target(self, target_path: Path) -> Optional[Path]:
        """Find appropriate base directory that contains the target path."""
        current_base = Path(self.base_dir_input.text())
        try:
            target_path.relative_to(current_base)
            return current_base
        except ValueError:
            if self.config.paths.project_base.exists():
                try:
                    target_path.relative_to(self.config.paths.project_base)
                    return self.config.paths.project_base
                except ValueError:
                    pass
            return target_path.parent if target_path.parent != target_path else target_path

    def add_navigation_history(self, path: Path):
        """Add navigation to history."""
        print(f"DEBUG: add_navigation_history called with {path}, programmatic={self.programmatic_navigation}")

        if not self.programmatic_navigation:
            print(f"DEBUG: Adding {path} to navigation history")
            self.history_service.add_navigation(path)
        else:
            print(f"DEBUG: Skipping history add - programmatic navigation")

    def navigate_to_directory(self, target_dir):
        """Navigate to directory."""
        if not self.tree_model:
            return

        index = self.tree_model.find_path_index(Path(target_dir))
        if index and index.isValid():
            self.tree_view.setCurrentIndex(index)
            self.tree_view.scrollTo(index)
            self.add_navigation_history(Path(target_dir))

    # CHANGE DETECTION METHODS

    @pyqtSlot(list)
    def on_changes_detected(self, changes: List[DirectoryChange]):
        """Handle detected directory changes after refresh."""
        updated_paths = [change.path for change in changes if change.is_updated]

        if updated_paths:
            logger.info(f"Detected {len(updated_paths)} updated directories")
            self.updated_dirs_widget.set_updated_directories(updated_paths)

            change_types = {}
            for change in changes:
                change_types[change.change_type] = change_types.get(change.change_type, 0) + 1

            summary = ", ".join([f"{count} {ctype}" for ctype, count in change_types.items()])
            self.show_status_message(f"Updates detected: {summary}", 5000)

    @pyqtSlot()
    def on_updates_cleared(self):
        """Handle when user clears the updates widget."""
        logger.info("Updated directories cleared by user")
        self.show_status_message("Updates cleared", 2000)

    # HIERARCHY AND UI UPDATE METHODS

    @pyqtSlot(DirectoryHierarchy)
    def on_hierarchy_updated(self, hierarchy: DirectoryHierarchy):
        """Handle updated directory hierarchy with change detection."""
        logger.info(f"Directory hierarchy updated, max depth: {hierarchy.calculate_max_depth()}")

        # Detect changes from previous hierarchy
        if self.current_hierarchy:
            self.change_service.detect_changes(hierarchy)
        else:
            # First load - just capture state
            self.change_service.capture_state(hierarchy)

        self.current_hierarchy = hierarchy
        self.max_depth = hierarchy.calculate_max_depth()

        self.depth_controls.update_depth_buttons(self.max_depth)
        self.status_widget.update_depth_status(self.current_depth, self.max_depth)

        self.update_tree_view()
        self.auto_expand_user_workspace()

    def update_tree_view(self):
        """Update tree view with current hierarchy and filter."""
        if not self.current_hierarchy:
            return

        filtered_hierarchy = self.directory_service.apply_filter(
            self.current_hierarchy,
            self.current_filter
        )

        self.tree_model = DirectoryTreeModel(
            filtered_hierarchy,
            self.current_filter,
            self.memo_service.memo_collection,
            self.config
        )

        self.tree_view.setModel(self.tree_model)
        self.apply_highlighting()

    def apply_highlighting(self):
        """Apply highlighting patterns exactly like original code."""
        if not self.tree_model:
            return

        # Clear existing highlights
        self.blinking_delegate.clear_blinking_items()

        # Get current user and patterns
        username = getpass.getuser()
        user_pattern = f"works_{username}"

        # Get environment variables for pattern matching
        design_ver = os.getenv('casino_design_ver', '')
        dk_ver = os.getenv('casino_dk_ver', '')
        tag = os.getenv('casino_tag', '')

        # Apply highlighting using original color logic
        if design_ver and dk_ver and tag:
            env_pattern = f"{design_ver}_{dk_ver}_{tag}"
            self.tree_model.highlight_pattern(env_pattern, "#045AB7", priority=100)
            print(f"DEBUG: Applied BLUE highlighting for environment pattern: {env_pattern}")

        # Apply red color ONLY for current user's workspace (exact match)
        self.tree_model.highlight_pattern(user_pattern, "brown", priority=80, exact_match=True)
        print(f"DEBUG: Applied BROWN highlighting for EXACT user pattern: {user_pattern}")

        # Add blinking effect for current user's workspace only
        user_indexes = self.tree_model.find_pattern_indexes(user_pattern)
        for index in user_indexes:
            self.blinking_delegate.add_blinking_item(index, user_pattern)

    def auto_expand_user_workspace(self):
        """Automatically expand to user workspace if found."""
        if not self.tree_model:
            return

        user_pattern = self.config.get_user_workspace_pattern()
        user_index = self.tree_model.find_pattern_index(user_pattern)

        if user_index and user_index.isValid():
            self.tree_view.setExpanded(user_index, True)
            self.tree_view.setCurrentIndex(user_index)

            item_depth = self.tree_model.get_item_depth(user_index)
            self.current_depth = item_depth
            self.depth_controls.set_current_depth(item_depth)
            self.status_widget.update_depth_status(self.current_depth, self.max_depth)

    @pyqtSlot(bool)
    def on_user_filter_toggled(self, me_only: bool):
        """Handle user filter toggle."""
        self.current_filter.show_only_user_workspace = me_only
        if me_only:
            self.current_filter.user_name = getpass.getuser()

        self.update_tree_view()
        logger.info(f"User filter toggled: {'me_only' if me_only else 'all_users'}")

    @pyqtSlot(str)
    def on_sort_order_changed(self, sort_order: str):
        """Handle sort order change."""
        self.current_filter.sort_by = sort_order
        self.update_tree_view()
        logger.info(f"Sort order changed: {sort_order}")

    @pyqtSlot(int)
    def set_depth_level(self, level: int):
        """Set tree expansion depth level."""
        self.current_depth = level
        self.status_widget.update_depth_status(self.current_depth, self.max_depth)

        if self.tree_model:
            self.tree_model.expand_to_depth(self.tree_view, level)

    @pyqtSlot(list)
    def on_selection_changed(self, selected_paths: List[Path]):
        """Handle tree view selection changes."""
        if selected_paths and self.tree_model:
            first_path = selected_paths[0]
            index = self.tree_model.find_path_index(first_path)
            if index and index.isValid():
                depth = self.tree_model.get_item_depth(index)
                self.current_depth = depth
                self.depth_controls.set_current_depth(depth)
                self.status_widget.update_depth_status(self.current_depth, self.max_depth)

    @pyqtSlot(str, int)
    def on_progress_updated(self, message: str, progress: int):
        """Handle progress updates - use bottom progress bar for scanning."""
        if ("Scanning" in message or "directory" in message.lower() or
            "scan" in message.lower() or "Starting" in message):
            self.scan_progress_bar.show_progress("", progress)
            if progress >= 100:
                QTimer.singleShot(1500, self.scan_progress_bar.hide_progress)
        else:
            self.progress_widget.show_progress(message, progress)

    @pyqtSlot(str, bool)
    def on_operation_completed(self, operation: str, success: bool):
        """Handle completed operations."""
        self.progress_widget.hide_progress()

        if success:
            logger.info(f"Operation completed successfully: {operation}")
        else:
            logger.error(f"Operation failed: {operation}")
            QMessageBox.warning(self, "Operation Failed", f"Operation failed: {operation}")

    def update_history_button_states(self):
        """Update history button states when history changes."""
        if hasattr(self, 'history_navigation') and self.history_navigation:
            self.history_navigation.update_button_states()

    def on_history_current_changed(self, path, operation):
        """Handle history current position changes."""
        if hasattr(self, 'history_navigation') and self.history_navigation:
            self.history_navigation.update_current_display(path, operation)

    # CONTEXT MENU AND CLIPBOARD

    def show_context_menu(self, position):
        """Show context menu for tree view with better color contrast."""
        selected_paths = self.get_selected_paths()
        if not selected_paths:
            return

        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #f5f5f5;
                border: 1px solid #cccccc;
                padding: 4px;
                font-size: 11px;
            }
            QMenu::item {
                background-color: transparent;
                color: #333333;
                padding: 6px 14px;
                margin: 0px;
            }
            QMenu::item:selected {
                background-color: #e0e0e0;
                color: #333333;
            }
            QMenu::item:hover {
                background-color: #e0e0e0;
                color: #333333;
            }
            QMenu::item:disabled {
                color: #999999;
            }
            QMenu::separator {
                height: 1px;
                background-color: #cccccc;
                margin: 4px 8px;
            }
        """)

        # Copy full path action
        copy_full_path_action = menu.addAction("Copy Full Path")
        copy_full_path_action.triggered.connect(lambda: self.copy_full_paths_to_clipboard(selected_paths))

        # Copy directory name action
        copy_name_action = menu.addAction("Copy Directory Name")
        copy_name_action.triggered.connect(lambda: self.copy_names_to_clipboard(selected_paths))

        # Memo actions (only for single selection)
        if len(selected_paths) == 1:
            path = selected_paths[0]
            menu.addSeparator()

            if self.memo_service.has_memo(path):
                view_memo_action = menu.addAction("View Memo")
                view_memo_action.triggered.connect(lambda: self.view_memo(path))

            add_memo_action = menu.addAction("Add/Edit Memo")
            add_memo_action.triggered.connect(self.mark_selected_directory)

            if self.memo_service.has_memo(path):
                remove_memo_action = menu.addAction("Remove Memo")
                remove_memo_action.triggered.connect(lambda: self.remove_memo(path))

        menu.exec_(self.tree_view.viewport().mapToGlobal(position))

    def copy_full_paths_to_clipboard(self, paths: List[Path]):
        """Copy selected full paths to clipboard."""
        try:
            paths_text = "\n".join(str(path) for path in paths)
            clipboard = QApplication.clipboard()
            clipboard.setText(paths_text, QClipboard.Clipboard)

            if clipboard.supportsSelection():
                clipboard.setText(paths_text, QClipboard.Selection)

            message = f"Copied {len(paths)} full path(s) to clipboard"
            self.show_status_message(message)

        except Exception as e:
            print(f"ERROR: Failed to copy paths to clipboard: {e}")
            self.show_status_message(f"Failed to copy: {e}")

    def copy_names_to_clipboard(self, paths: List[Path]):
        """Copy selected directory names to clipboard."""
        try:
            names_text = "\n".join(path.name for path in paths)
            clipboard = QApplication.clipboard()
            clipboard.setText(names_text, QClipboard.Clipboard)

            if clipboard.supportsSelection():
                clipboard.setText(names_text, QClipboard.Selection)

            message = f"Copied {len(paths)} directory name(s) to clipboard"
            self.show_status_message(message)

        except Exception as e:
            print(f"ERROR: Failed to copy names to clipboard: {e}")
            self.show_status_message(f"Failed to copy: {e}")

    def show_status_message(self, message: str, duration: int = 3000):
        """Show temporary status message."""
        self.status_widget.set_help_text(message)
        QTimer.singleShot(duration, lambda: self.status_widget.set_help_text(
            #"Help: Use arrow keys to navigate and Enter to go to the chosen directory."
            ""
        ))

    # CORE OPERATIONS (Clone, Trash, Restore, Delete)

    @pyqtSlot()
    def clone_selected_directory(self):
        """Clone selected directory."""
        selected_dir = self.get_selected_directory()
        if not selected_dir:
            QMessageBox.critical(self, "Error", "Please select a directory to clone.")
            return

        from ..ui.dialogs import CloneDialog
        dialog = CloneDialog(self.config, selected_dir, self.directory_service, self)
        if dialog.exec_() == dialog.Accepted:
            dest_name = dialog.new_dir_name_input.text().strip()
            if dest_name:
                source_path = Path(selected_dir)
                dest_path = source_path.parent / dest_name
                self.history_service.add_clone_operation(source_path, dest_path)
            QTimer.singleShot(500, self.refresh_directory_tree)

    @pyqtSlot()
    def move_selected_directory(self):
        """Move selected directories to TrashBin with proper permission handling."""
        selected_indexes = self.tree_view.selectedIndexes()
        if not selected_indexes:
            QMessageBox.critical(self, "Error", "Please select one or more directories to move.")
            return

        selected_dirs = set()
        for index in selected_indexes:
            dir_path = index.data(Qt.UserRole)
            if dir_path:
                selected_dirs.add(dir_path)

        if not selected_dirs:
            QMessageBox.critical(self, "Error", "No valid directories selected for removal.")
            return

        reply = QMessageBox.question(
            self,
            'Confirmation',
            f"Are you sure you want to move {len(selected_dirs)} selected directories to TrashBin?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply != QMessageBox.Yes:
            return

        first_dir = list(selected_dirs)[0]
        parent_dir = os.path.dirname(first_dir)
        trash_bin = os.path.join(parent_dir, "TrashBin")

        try:
            if not os.path.exists(trash_bin):
                os.makedirs(trash_bin)
                logger.info(f"Created TrashBin directory: {trash_bin}")
            elif not os.access(trash_bin, os.W_OK):
                raise PermissionError(f"No write permission to TrashBin: {trash_bin}")

        except PermissionError as e:
            current_user = getpass.getuser()
            parent_owner = self._get_directory_owner(parent_dir)

            error_msg = (
                f"Permission denied: Cannot create or access TrashBin.\n\n"
                f"Location: {trash_bin}\n"
                f"Current user: {current_user}\n"
                f"Directory owner: {parent_owner or 'unknown'}\n\n"
                f"This usually happens when trying to move files in another user's workspace. "
                f"You may need to:\n"
                f"? Ask the directory owner ({parent_owner}) to move these files\n"
                f"? Use system commands with appropriate permissions\n"
                f"? Contact your system administrator"
            )

            QMessageBox.warning(self, "Permission Error", error_msg)
            logger.warning(f"TrashBin permission error: {e}")
            return

        except Exception as e:
            error_msg = (
                f"Failed to create TrashBin directory.\n\n"
                f"Location: {trash_bin}\n"
                f"Error: {str(e)}\n\n"
                f"Please check:\n"
                f"? Available disk space\n"
                f"? Directory permissions\n"
                f"? File system restrictions"
            )

            QMessageBox.critical(self, "TrashBin Error", error_msg)
            logger.error(f"Failed to create TrashBin: {e}")
            return

        errors = []
        moved_paths = []
        permission_errors = []

        for selected_dir in selected_dirs:
            try:
                if not os.access(os.path.dirname(selected_dir), os.W_OK):
                    permission_errors.append(selected_dir)
                    continue

                shutil.move(selected_dir, trash_bin)
                moved_paths.append(Path(selected_dir))
                logger.info(f"Moved to trash: {selected_dir}")

            except PermissionError:
                permission_errors.append(selected_dir)
            except Exception as e:
                errors.append(f"Failed to move {os.path.basename(selected_dir)}: {str(e)}")
                logger.error(f"Move error for {selected_dir}: {e}")

        if permission_errors:
            current_user = getpass.getuser()
            perm_error_msg = (
                f"Permission denied for {len(permission_errors)} directories.\n\n"
                f"Current user: {current_user}\n"
                f"Directories with permission issues:\n" +
                "\n".join([f"? {os.path.basename(d)}" for d in permission_errors[:5]]) +
                (f"\n? ... and {len(permission_errors) - 5} more" if len(permission_errors) > 5 else "") +
                f"\n\nThese directories are likely owned by other users. "
                f"Contact the directory owners or system administrator for assistance."
            )
            QMessageBox.warning(self, "Permission Errors", perm_error_msg)

        if errors:
            QMessageBox.warning(
                self,
                "Move Errors",
                f"Some directories could not be moved:\n\n" + "\n".join(errors)
            )

        if moved_paths:
            success_count = len(moved_paths)
            QMessageBox.information(
                self,
                "Move Completed",
                f"Successfully moved {success_count} director{'y' if success_count == 1 else 'ies'} to TrashBin."
            )

            self.history_service.add_trash_operation(moved_paths, Path(trash_bin))
            self.refresh_directory()
            self.navigate_to_directory(trash_bin)
        elif not permission_errors and not errors:
            QMessageBox.information(self, "No Action", "No directories were moved.")

    def _get_directory_owner(self, directory_path: str) -> Optional[str]:
        """Get the owner of a directory."""
        try:
            import pwd
            stat_info = os.stat(directory_path)
            owner_uid = stat_info.st_uid
            owner_info = pwd.getpwuid(owner_uid)
            return owner_info.pw_name
        except (ImportError, OSError, KeyError):
            return None

    @pyqtSlot()
    def restore_selected_directory(self):
        """Restore selected directories from TrashBin."""
        selected_indexes = self.tree_view.selectedIndexes()
        if not selected_indexes:
            QMessageBox.critical(self, "Error", "Please select one or more directories to restore.")
            return

        selected_dirs = set()
        for index in selected_indexes:
            dir_path = index.data(Qt.UserRole)
            if dir_path:
                selected_dirs.add(dir_path)

        if not selected_dirs:
            QMessageBox.critical(self, "Error", "No valid directories selected for restoration.")
            return

        valid_dirs = {d for d in selected_dirs if "/TrashBin/" in d}
        invalid_dirs = selected_dirs - valid_dirs

        if invalid_dirs:
            QMessageBox.information(
                self,
                "Invalid Selection",
                "The following directories are not in TrashBin and will not be restored:\n" + "\n".join(invalid_dirs)
            )
            return

        reply = QMessageBox.question(
            self,
            'Confirmation',
            f"Are you sure you want to restore {len(valid_dirs)} selected directories from TrashBin?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            errors = []
            restored_paths = []

            for selected_dir in valid_dirs:
                trash_bin = os.path.dirname(selected_dir)
                restore_path = os.path.join(os.path.dirname(trash_bin), os.path.basename(selected_dir))
                try:
                    shutil.move(selected_dir, restore_path)
                    restored_paths.append(Path(selected_dir))
                except Exception as e:
                    errors.append(f"Failed to restore {selected_dir}: {str(e)}")

            if errors:
                QMessageBox.warning(self, "Errors Occurred", "\n".join(errors))
            else:
                QMessageBox.information(self, "Success", "Selected directories successfully restored.")

            if restored_paths:
                self.history_service.add_restore_operation(restored_paths)

            self.refresh_directory()
            self.navigate_to_directory(trash_bin)

    @pyqtSlot()
    def remove_selected_directory(self):
        """Permanently delete selected directories."""
        selected_indexes = self.tree_view.selectedIndexes()
        if not selected_indexes:
            QMessageBox.critical(self, "Error", "Please select one or more directories to delete.")
            return

        selected_dirs = set()
        for index in selected_indexes:
            dir_path = index.data(Qt.UserRole)
            if dir_path:
                selected_dirs.add(dir_path)

        if not selected_dirs:
            QMessageBox.critical(self, "Error", "No valid directories selected for deletion.")
            return

        reply = QMessageBox.question(
            self,
            'Initial Confirmation',
            f"You are about to delete {len(selected_dirs)} directories permanently.\n"
            "Would you like to review this decision before proceeding?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply == QMessageBox.No:
            return

        final_reply = QMessageBox.question(
            self,
            'Final Confirmation',
            "The following directories will be deleted permanently:\n" +
            "\n".join(selected_dirs) + "\n\nAre you sure you want to proceed?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if final_reply == QMessageBox.Yes:
            errors = []
            parent_dirs = set()
            deleted_paths = []

            for selected_dir in selected_dirs:
                parent_dirs.add(os.path.dirname(selected_dir))
                try:
                    shutil.rmtree(selected_dir)
                    deleted_paths.append(Path(selected_dir))
                except Exception as e:
                    errors.append(f"Failed to delete {selected_dir}: {str(e)}")

            if errors:
                QMessageBox.warning(self, "Errors Occurred", "\n".join(errors))
            else:
                QMessageBox.information(self, "Success", "All selected directories have been permanently deleted.")

            if deleted_paths:
                self.history_service.add_delete_operation(deleted_paths)

            self.refresh_directory()
            if parent_dirs:
                self.navigate_to_directory(parent_dirs.pop())

    # MEMO FUNCTIONS

    def mark_selected_directory(self):
        """Add/edit memo for selected directory."""
        selected_index = self.tree_view.currentIndex()
        if not selected_index.isValid():
            QMessageBox.critical(self, "Error", "Please select a directory to mark.")
            return

        dir_path = selected_index.data(Qt.UserRole)
        if not dir_path:
            return

        existing_memo = self.memo_service.get_memo(Path(dir_path))

        from ..ui.widgets import MemoDialog
        dialog = MemoDialog(self.config, Path(dir_path), existing_memo, self)
        if dialog.exec_() == dialog.Accepted:
            memo_text = dialog.get_memo_text()
            if memo_text:
                self.memo_service.add_memo(Path(dir_path), memo_text)
                self.update_tree_view()
                self.navigate_to_directory(dir_path)

    def remove_memo(self, path: Path):
        """Remove memo for directory."""
        if self.memo_service.remove_memo(path):
            self.update_tree_view()
            self.navigate_to_directory(str(path))

    def view_memo(self, path: Path):
        """View memo details."""
        memo = self.memo_service.get_memo(path)
        if memo:
            from ..ui.widgets import MemoViewerDialog
            dialog = MemoViewerDialog(self.config, path, memo, self)
            dialog.exec_()

    def view_selected_memo(self):
        """View memo for currently selected directory."""
        selected_index = self.tree_view.currentIndex()
        if selected_index.isValid():
            dir_path = selected_index.data(Qt.UserRole)
            if dir_path and self.memo_service.has_memo(Path(dir_path)):
                self.view_memo(Path(dir_path))

    def on_memo_changed(self):
        """Handle memo changes."""
        logger.info("Memo collection changed")
        if self.tree_model:
            self.tree_model.update_memo_collection(self.memo_service.memo_collection)

    def on_memos_loaded(self, memo_collection):
        """Handle memos loaded."""
        logger.info("Loaded memos")
        if self.tree_model:
            self.tree_model.update_memo_collection(memo_collection)

    @pyqtSlot(str)
    def on_memo_error(self, error: str):
        """Handle memo service errors."""
        logger.error(f"Memo service error: {error}")
        QMessageBox.warning(self, "Memo Error", f"Memo operation failed: {error}")

    # UTILITY METHODS

    def get_selected_directory(self):
        """Get single selected directory."""
        index = self.tree_view.currentIndex()
        if not index.isValid():
            return None
        dir_path = index.data(Qt.UserRole)
        return dir_path if dir_path else None

    def get_selected_paths(self) -> List[Path]:
        """Get currently selected directory paths."""
        if not self.tree_view or not self.tree_view.selectedIndexes():
            return []

        paths = []
        for index in self.tree_view.selectedIndexes():
            path_data = index.data(Qt.UserRole)
            if path_data:
                paths.append(Path(path_data))

        return paths

    def refresh_directory(self):
        """Refresh directory."""
        selected_index = self.tree_view.currentIndex()
        selected_path = selected_index.data(Qt.UserRole) if selected_index.isValid() else None

        self.tree_view.setModel(None)
        self.memo_service.load_memos()
        self.current_hierarchy = None
        self.refresh_directory_tree()

        if selected_path:
            self.select_directory_path(selected_path)
            self.tree_view.viewport().update()
            self.tree_view.scrollTo(self.tree_view.currentIndex())

    def select_directory_path(self, path):
        """Select directory path in tree view."""
        if not self.tree_model:
            return

        index = self.tree_model.find_path_index(Path(path))
        if index and index.isValid():
            self.tree_view.setCurrentIndex(index)
            self.tree_view.scrollTo(index, self.tree_view.PositionAtCenter)

    def keyPressEvent(self, event):
        """Handle main window key press events."""
        if event.key() == Qt.Key_V and event.modifiers() == Qt.ControlModifier:
            self.view_selected_memo()
        elif event.key() == Qt.Key_Left and event.modifiers() == Qt.AltModifier:
            self.go_back()
        elif event.key() == Qt.Key_Right and event.modifiers() == Qt.AltModifier:
            self.go_forward()
        elif event.key() == Qt.Key_Escape:
            if self.updated_dirs_widget.has_updates():
                self.updated_dirs_widget.clear_updates()
        else:
            super().keyPressEvent(event)


===== FILE: ./utils/logger.py =====
"""
Logging configuration for the Treem Casino application.
Provides structured logging with different levels and formatters.
"""

import logging
import logging.handlers
from pathlib import Path
from typing import Optional
import sys


def setup_logging(log_level: str = "INFO", log_file: Optional[Path] = None):
    """Setup application logging configuration."""

    # Create formatter
    formatter = logging.Formatter(
        fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # Setup root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, log_level.upper()))

    # Clear existing handlers
    root_logger.handlers.clear()

    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(formatter)
    root_logger.addHandler(console_handler)

    # File handler (if specified)
    if log_file:
        try:
            log_file.parent.mkdir(parents=True, exist_ok=True)
            file_handler = logging.handlers.RotatingFileHandler(
                log_file,
                maxBytes=10*1024*1024,  # 10MB
                backupCount=5
            )
            file_handler.setLevel(logging.DEBUG)
            file_handler.setFormatter(formatter)
            root_logger.addHandler(file_handler)
        except Exception as e:
            print(f"Warning: Could not setup file logging: {e}")

    # Set specific logger levels
    logging.getLogger('PyQt5').setLevel(logging.WARNING)

    # Application logger
    app_logger = logging.getLogger('treem_casino')
    app_logger.info("Logging configured successfully")


def get_logger(name: str) -> logging.Logger:
    """Get a logger instance for the given name."""
    return logging.getLogger(f'treem_casino.{name}')


===== FILE: ./utils/__init__.py =====


===== FILE: ./utils/tree_model.py =====
"""
Tree model implementation with FIXED color highlighting logic and memo tooltips.
Supports proper priority handling for overlapping patterns and recursive coloring.
"""

import getpass
from pathlib import Path
from typing import Optional, Any, Dict, List
from PyQt5.QtCore import QAbstractItemModel, QModelIndex, Qt, QVariant
from PyQt5.QtGui import QFont, QColor, QBrush

from ..models.directory import DirectoryHierarchy, DirectoryFilter
from ..models.memo import MemoCollection
from ..config.settings import AppConfig


class TreeItem:
    """A tree item that holds directory information."""

    def __init__(self, directory_hierarchy: DirectoryHierarchy, parent: Optional['TreeItem'] = None):
        self.directory_hierarchy = directory_hierarchy
        self.parent_item = parent
        self.child_items: List['TreeItem'] = []
        self.memo_collection: Optional[MemoCollection] = None

        # Create child items
        for child_hierarchy in directory_hierarchy.children.values():
            child_item = TreeItem(child_hierarchy, self)
            self.child_items.append(child_item)

    def child(self, row: int) -> Optional['TreeItem']:
        """Get child item at row."""
        if 0 <= row < len(self.child_items):
            return self.child_items[row]
        return None

    def child_count(self) -> int:
        """Get number of child items."""
        return len(self.child_items)

    def column_count(self) -> int:
        """Get number of columns."""
        return 1

    def data(self, column: int = 0) -> Any:
        """Get data for column."""
        if column == 0:
            name = self.directory_hierarchy.root.display_name
            # Add memo first line instead of "*"
            if self.memo_collection and self.memo_collection.has_memo(self.directory_hierarchy.root.path):
                memo = self.memo_collection.get_memo(self.directory_hierarchy.root.path)
                if memo:
                    # Get first line of memo text
                    first_line = memo.text.split('\n')[0].strip()
                    if len(first_line) > 50:  # Limit length
                        first_line = first_line[:47] + "..."
                    return f"{name} : {first_line}"
            return name
        return None

    def parent(self) -> Optional['TreeItem']:
        """Get parent item."""
        return self.parent_item

    def row(self) -> int:
        """Get row number in parent."""
        if self.parent_item:
            return self.parent_item.child_items.index(self)
        return 0

    def path(self) -> Path:
        """Get directory path."""
        return self.directory_hierarchy.root.path

    def set_memo_collection(self, memo_collection: MemoCollection):
        """Set memo collection for memo indicators."""
        self.memo_collection = memo_collection
        for child in self.child_items:
            child.set_memo_collection(memo_collection)


class DirectoryTreeModel(QAbstractItemModel):
    """Qt model for directory tree display with proper color highlighting and memo tooltips."""

    def __init__(self, hierarchy: DirectoryHierarchy, filter_config: DirectoryFilter,
                 memo_collection: MemoCollection, config: AppConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.filter_config = filter_config
        self.memo_collection = memo_collection

        # Create root item
        self.root_item = TreeItem(hierarchy)
        self.root_item.set_memo_collection(memo_collection)

        # Sort children according to filter
        self._sort_items()

        # Highlighting patterns with priorities
        self.highlight_patterns: Dict[str, Dict[str, Any]] = {}  # pattern -> {color: str, priority: int}

    def _sort_items(self):
        """Sort tree items according to filter configuration."""
        def sort_key(item: TreeItem):
            return self.filter_config.get_sort_key(item.directory_hierarchy.root)

        self._sort_item_recursive(self.root_item, sort_key)

    def _sort_item_recursive(self, item: TreeItem, sort_key_func):
        """Recursively sort tree items."""
        item.child_items.sort(key=sort_key_func)
        for child in item.child_items:
            self._sort_item_recursive(child, sort_key_func)

    def columnCount(self, parent: QModelIndex = QModelIndex()) -> int:
        """Get number of columns."""
        return 1

    def data(self, index: QModelIndex, role: int = Qt.DisplayRole) -> Any:
        """Get data for model index with FIXED tooltip behavior."""
        if not index.isValid():
            return QVariant()

        item = index.internalPointer()
        if not isinstance(item, TreeItem):
            return QVariant()

        if role == Qt.DisplayRole:
            return item.data(index.column())

        elif role == Qt.UserRole:
            # Return path as string for external use
            return str(item.path())

        elif role == Qt.FontRole:
            font = QFont(*self.config.fonts.get_font_tuple())
            item_text = item.data(index.column()) or ""

            # Check if this item has memo text (contains " : ")
            if " : " in item_text:
                # This has memo text - make the entire text smaller and italic
                font.setPointSize(font.pointSize() - 1)  # Smaller font
                font.setItalic(True)  # Italic font
                return font

            # Bold font ONLY for current user's workspace
            username = getpass.getuser()
            user_workspace_pattern = f"works_{username}"

            # Check if this is exactly the user's workspace (for exact match) or contains it
            dir_name_part = item_text.split(" : ")[0] if " : " in item_text else item_text
            if dir_name_part == user_workspace_pattern or user_workspace_pattern in dir_name_part:
                font.setBold(True)

            return font

        elif role == Qt.ForegroundRole:
            item_text = item.data(index.column()) or ""
            item_path = item.path()

            # Check if this item is under works_{whoami} directory
            is_under_user_workspace = False
            username = getpass.getuser()
            user_workspace_pattern = f"works_{username}"

            # Check if current item or any parent contains user workspace
            current_path = item_path
            while current_path != current_path.parent:
                if user_workspace_pattern in str(current_path):
                    is_under_user_workspace = True
                    break
                current_path = current_path.parent

            # Find the highest priority matching pattern
            best_match = None
            highest_priority = -1

            for pattern, pattern_info in self.highlight_patterns.items():
                is_exact_match = pattern_info.get('exact_match', False)

                # Check if pattern matches - handle memo format "name : memo text"
                pattern_matches = False
                if is_exact_match:
                    # For exact match, check the directory name part (before " : ")
                    dir_name_part = item_text.split(" : ")[0] if " : " in item_text else item_text
                    pattern_matches = (dir_name_part == pattern)
                else:
                    # For normal match, pattern can be contained in the directory name part
                    dir_name_part = item_text.split(" : ")[0] if " : " in item_text else item_text
                    pattern_matches = (pattern in dir_name_part)

                if pattern_matches:
                    priority = pattern_info.get('priority', 0)
                    if priority > highest_priority:
                        highest_priority = priority
                        best_match = pattern_info

            # Apply recursive brown color for items under user workspace
            if is_under_user_workspace and not best_match:
                # Apply brown color for items under user workspace that don't have other patterns
                color = QColor("brown")
                return QBrush(color)

            if best_match:
                color = QColor(best_match['color'])
                return QBrush(color)

            # Default text color
            default_color = QColor(self.config.colors.text_primary)
            return QBrush(default_color)

        elif role == Qt.ToolTipRole:
            # FIXED: Show ONLY memo information in tooltip when hovering
            item_path = item.path()

            if self.memo_collection.has_memo(item_path):
                memo = self.memo_collection.get_memo(item_path)
                if memo:
                    # Show only memo information - more concise
                    tooltip_parts = []
                    tooltip_parts.append(f"Memo by {memo.user} ({memo.formatted_timestamp}):")
                    tooltip_parts.append(memo.text)
                    return "\n".join(tooltip_parts)

            # No tooltip if no memo - let users hover only when needed
            return QVariant()

        return QVariant()

    def flags(self, index: QModelIndex) -> Qt.ItemFlags:
        """Get item flags."""
        if not index.isValid():
            return Qt.NoItemFlags

        return Qt.ItemIsEnabled | Qt.ItemIsSelectable

    def headerData(self, section: int, orientation: Qt.Orientation, role: int = Qt.DisplayRole) -> Any:
        """Get header data."""
        if orientation == Qt.Horizontal and role == Qt.DisplayRole and section == 0:
            return "Directories"
        return QVariant()

    def index(self, row: int, column: int, parent: QModelIndex = QModelIndex()) -> QModelIndex:
        """Create model index."""
        if not self.hasIndex(row, column, parent):
            return QModelIndex()

        if not parent.isValid():
            parent_item = self.root_item
        else:
            parent_item = parent.internalPointer()

        child_item = parent_item.child(row)
        if child_item:
            return self.createIndex(row, column, child_item)
        else:
            return QModelIndex()

    def parent(self, index: QModelIndex) -> QModelIndex:
        """Get parent model index."""
        if not index.isValid():
            return QModelIndex()

        child_item = index.internalPointer()
        parent_item = child_item.parent()

        if parent_item == self.root_item or parent_item is None:
            return QModelIndex()

        return self.createIndex(parent_item.row(), 0, parent_item)

    def rowCount(self, parent: QModelIndex = QModelIndex()) -> int:
        """Get number of rows."""
        if parent.column() > 0:
            return 0

        if not parent.isValid():
            parent_item = self.root_item
        else:
            parent_item = parent.internalPointer()

        return parent_item.child_count()

    def highlight_pattern(self, pattern: str, color_string: str, priority: int = 1, exact_match: bool = False):
        """Add pattern highlighting with priority and exact match support."""
        self.highlight_patterns[pattern] = {
            'color': color_string,
            'priority': priority,
            'exact_match': exact_match
        }

        print(f"DEBUG: Added highlighting pattern '{pattern}' with color '{color_string}', priority {priority}, exact_match: {exact_match}")

        # Emit data changed for all items
        self.dataChanged.emit(
            self.index(0, 0),
            self.index(self.rowCount() - 1, 0),
            [Qt.ForegroundRole, Qt.FontRole]
        )

    def clear_highlighting(self):
        """Clear all pattern highlighting."""
        self.highlight_patterns.clear()

        # Emit data changed for all items
        self.dataChanged.emit(
            self.index(0, 0),
            self.index(self.rowCount() - 1, 0),
            [Qt.ForegroundRole, Qt.FontRole]
        )

    def find_pattern_indexes(self, pattern: str) -> List[QModelIndex]:
        """Find all indexes matching a pattern."""
        matches = []
        self._find_pattern_recursive(self.root_item, pattern, matches)
        return matches

    def find_pattern_index(self, pattern: str) -> Optional[QModelIndex]:
        """Find first index matching a pattern."""
        matches = self.find_pattern_indexes(pattern)
        return matches[0] if matches else None

    def _find_pattern_recursive(self, item: TreeItem, pattern: str, matches: List[QModelIndex]):
        """Recursively find pattern matches."""
        for row, child in enumerate(item.child_items):
            child_text = child.data(0) or ""
            if pattern in child_text:
                index = self.createIndex(row, 0, child)
                matches.append(index)

            # Recurse into children
            self._find_pattern_recursive(child, pattern, matches)

    def find_path_index(self, target_path: Path) -> Optional[QModelIndex]:
        """Find index for a specific path."""
        return self._find_path_recursive(self.root_item, target_path)

    def _find_path_recursive(self, item: TreeItem, target_path: Path) -> Optional[QModelIndex]:
        """Recursively find path index."""
        for row, child in enumerate(item.child_items):
            if child.path() == target_path:
                return self.createIndex(row, 0, child)

            # Recurse into children
            result = self._find_path_recursive(child, target_path)
            if result:
                return result

        return None

    def get_item_depth(self, index: QModelIndex) -> int:
        """Get depth of item in tree."""
        depth = 0
        current = index

        while current.isValid():
            current = self.parent(current)
            depth += 1

        return depth

    def expand_to_depth(self, tree_view, target_depth: int):
        """Expand tree view to specified depth."""
        tree_view.collapseAll()

        if target_depth <= 0:
            return

        # Expand items up to target depth
        self._expand_to_depth_recursive(tree_view, QModelIndex(), 0, target_depth)

    def _expand_to_depth_recursive(self, tree_view, parent_index: QModelIndex, current_depth: int, target_depth: int):
        """Recursively expand items to target depth."""
        if current_depth > target_depth:
            return

        # Expand current level
        if parent_index.isValid():
            tree_view.setExpanded(parent_index, True)

        # Process children
        row_count = self.rowCount(parent_index)
        for row in range(row_count):
            child_index = self.index(row, 0, parent_index)
            if child_index.isValid():
                # Check if we should expand this item
                item = child_index.internalPointer()
                if item:
                    item_text = item.data(0) or ""

                    # Special handling for user workspace
                    if current_depth == 0 and not item_text.startswith("works_"):
                        continue  # Skip non-workspace directories at root level

                    # Expand if within depth limit or if it's a runs directory
                    if current_depth < target_depth or "runs" in item_text:
                        self._expand_to_depth_recursive(tree_view, child_index, current_depth + 1, target_depth)

    def update_memo_collection(self, memo_collection: MemoCollection):
        """Update memo collection and refresh display."""
        self.memo_collection = memo_collection
        self.root_item.set_memo_collection(memo_collection)

        # Emit data changed to update memo indicators
        self.dataChanged.emit(
            self.index(0, 0),
            self.index(self.rowCount() - 1, 0),
            [Qt.DisplayRole, Qt.ToolTipRole]
        )


===== FILE: ./collect.csh =====
#!/usr/bin/csh



# Create/reset the output file
rm -f ./prj_hawkeye_full_dump.txt

foreach f (`find . -type f | grep -v "__pycache__" | egrep -v '\.sw[a-z]$'`)
    echo "===== FILE: $f =====" >> ./prj_hawkeye_full_dump.txt
    cat $f >> ./prj_hawkeye_full_dump.txt
    echo "\n" >> ./prj_hawkeye_full_dump.txt
end



===== FILE: ./treem_casino.py =====
#!/usr/local/bin/python3.12
"""
Treem Casino - Enhanced Directory Management Application
Main entry point for the modular directory tracer application.
"""

import sys
from pathlib import Path
from PyQt5.QtWidgets import QApplication

# Add the treem_casino package to the path
current_dir = Path(__file__).parent
sys.path.insert(0, str(current_dir))

from treem_casino.ui.main_window import MainWindow
from treem_casino.config.settings import AppConfig
from treem_casino.utils.logger import setup_logging


def main():
    """Main entry point for the application."""
    # Setup logging
    setup_logging()

    # Initialize Qt application
    app = QApplication(sys.argv)
    app.setApplicationName("Treem Casino")
    app.setApplicationVersion("2.0.0")
    app.setOrganizationName("Casino Project")

    # Load configuration
    config = AppConfig()

    # Create and show main window
    window = MainWindow(config)
    window.show()

    # Start event loop
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()


